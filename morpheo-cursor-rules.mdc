---
description: 
globs: 
alwaysApply: false
---
---
description: Comprehensive development rules for building and maintaining Morpheo
globs: 
alwaysApply: true
---
# Morpheo Core Purpose and Development Rules

Morpheo is an AI-driven component system with these fundamental principles:

## 1. No Hardcoded Domain-Specific Logic

1. **Zero Use Case-Specific Code**: 
   - No hardcoded calculator logic, form validation, or other domain-specific functionality
   - All application behavior must be generated by the AI, not pre-built

2. **Pure AI-Driven Generation**:
   - The AI analyzes requests and determines needed components
   - The AI creates connections and transformations
   - The AI applies behaviors appropriate to the use case

3. **Generic Component System**:
   - Components must be generic building blocks
   - Behaviors should be reusable across all domains
   - No component or behavior should be tied to a specific use case (e.g., no BitcoinChart, WeatherWidget, etc.)

## 2. Implementation Guidelines

1. **Pattern-Based Development**:
   - Focus on teaching the AI patterns rather than implementing specific solutions
   - Avoid domain type enums or switch statements based on application types
   - Do not create specialized handler methods for specific use cases

2. **Component Philosophy**:
   - Make components smarter, not domain-aware
   - Add defaults and validations that apply universally
   - All component selection, connection, and behavior must come from the AI

3. **DOM Manipulation Approach**:
   - Use direct DOM manipulation via the $m() selector for dynamic updates
   - Provide utilities that work across all domains and use cases
   - Validate all user input and handle edge cases generically

4. **Error Handling**:
   - Implement generic error handling that works for all domains
   - Add safety checks around evaluation and manipulation functions
   - Provide user feedback for errors in a consistent way

## 3. Prompt Engineering Principles

1. **Instruction Clarity**:
   - Be explicit about functional requirements without being domain-specific
   - Include examples that demonstrate patterns, not specific implementations
   - Request initialization, validation, and error handling for all components

2. **Balance**:
   - Guide the AI without constraining its creativity
   - Provide enough structure for functionality without dictating domain-specific logic
   - Use examples that can be applied across multiple domains and use cases

## 4. Testing and Validation

1. **Generic Testing**:
   - Test for functionality patterns, not specific domain behaviors
   - Verify components work together without assuming specific use cases
   - Validate that error handling works across all component interactions

2. **Continuous Improvement**:
   - Use feedback to improve prompts and components, not to add domain-specific logic
   - Learn from successful generations to identify universal patterns
   - Apply improvements systematically across the entire system

## 5. Development Safeguards

1. **Principle Protection**:
   - Flag and reject any proposals that introduce domain-specific or use case-specific logic
   - Challenge assumptions that restrict the AI's creative freedom
   - Always prioritize flexibility over specialized functionality

2. **Performance Awareness**:
   - Reject changes that would significantly slow generation speed
   - Favor lightweight solutions over complex processing
   - Be mindful of token consumption in prompts and responses
   - Balance functionality with performance to maintain responsiveness

3. **Directional Guidance**:
   - Provide constructive alternatives when rejecting problematic suggestions
   - Clearly explain when proposals contradict Morpheo's core principles
   - Suggest course corrections that align better with the AI-driven approach

## 6. Component Development Best Practices

1. **Search Before Creating**:
   - Always search for existing components before creating new ones
   - Review component registry to understand available building blocks
   - Leverage existing implementations rather than duplicating functionality

2. **Semantic Consistency**:
   - Use consistent naming conventions for similar functions
   - Maintain predictable property and method signatures
   - Document component interfaces clearly

3. **Progressive Enhancement**:
   - Build for base functionality first, then add advanced features
   - Ensure graceful degradation when features aren't available
   - Layer complexity incrementally to maintain reliability

## 7. AI Prompt Enhancement Strategy

1. **Context Maximization**:
   - Provide clear examples of pattern implementation
   - Include common anti-patterns to avoid
   - Demonstrate reusable techniques that work across many domains

2. **Comprehensive Documentation**:
   - Document component capabilities, limitations and integration patterns
   - Include expected behaviors and failure modes
   - Provide clear guidance on component composition

3. **Guidance Without Restriction**:
   - Suggest approaches without requiring specific implementations
   - Emphasize desired outcomes over particular coding techniques
   - Balance structure with creative freedom

Remember: The system provides only the tools and framework - the AI provides the domain logic. When in doubt, prioritize flexibility, speed, and AI-driven solutions over hardcoded behaviors. Never create components that serve only a single use case (like BitcoinChart, TodoList, or WeatherWidget) - instead, create generic components the AI can apply to any domain. 