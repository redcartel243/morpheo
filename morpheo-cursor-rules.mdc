---
description: 
globs: 
alwaysApply: false
---
---
description: Comprehensive development rules for building and maintaining Morpheo
globs: 
alwaysApply: true
---
# Morpheo Core Purpose and Development Rules

Morpheo is an AI-driven component system with these fundamental principles:

## 1. No Hardcoded Domain-Specific Logic

1. **Zero Use Case-Specific Code**: 
   - No hardcoded calculator logic, form validation, or other domain-specific functionality
   - All application behavior must be generated by the AI, not pre-built

2. **Pure AI-Driven Generation**:
   - The AI analyzes requests and determines needed components
   - The AI creates connections and transformations
   - The AI applies behaviors appropriate to the use case

3. **Generic Component System**:
   - Components must be generic building blocks
   - Behaviors should be reusable across all domains
   - No component or behavior should be tied to a specific use case (e.g., no BitcoinChart, WeatherWidget, etc.)

## 2. Implementation Guidelines

1. **Pattern-Based Development**:
   - Focus on teaching the AI patterns rather than implementing specific solutions
   - Avoid domain type enums or switch statements based on application types
   - Do not create specialized handler methods for specific use cases

2. **Component Philosophy**:
   - Make components smarter, not domain-aware
   - Add defaults and validations that apply universally
   - All component selection, connection, and behavior must come from the AI

3. **DOM Manipulation Approach**:
   - Use direct DOM manipulation via the $m() selector for dynamic updates
   - Provide utilities that work across all domains and use cases
   - Validate all user input and handle edge cases generically

4. **Error Handling**:
   - Implement generic error handling that works for all domains
   - Add safety checks around evaluation and manipulation functions
   - Provide user feedback for errors in a consistent way

## 2.5 Chakra UI v3 Integration

1.  **Primary Styling Method:** Prioritize using Chakra UI style props (e.g., `bg`, `p`, `color`) and theme tokens (e.g., `blue.500`) for styling components.
2.  **High Specificity Overrides:** For complex styles (like gradients) or to resolve conflicts with global/external CSS, utilize the `sx` prop with direct CSS properties, referencing theme tokens via `token()` where possible (e.g., `sx: { backgroundImage: "linear-gradient(...)" }`).
3.  **Component Naming:** Strictly adhere to Chakra UI v3 component names (e.g., use `Field`, `Dialog`, `Collapsible` instead of `FormControl`, `AlertDialog`, `Collapse`).
4.  **Prop Naming:** Strictly adhere to Chakra UI v3 prop names:
    *   Use `colorPalette` instead of `colorScheme`.
    *   Use direct boolean props (`disabled`, `invalid`, `required`, `open`) instead of the `is<X>` convention (`isDisabled`, `isInvalid`, etc.).
5.  **Icon Usage:** Avoid using Chakra's icon-related props (`icon`, `leftIcon`, `rightIcon`, etc.) as `@chakra-ui/icons` is removed. Icon integration requires a separate library (e.g., `lucide-react`) and specific implementation handling. (Future rule: Define how icon names should be passed via props if library is added).
6.  **Tailwind CSS Coexistence (If Applicable):**
    *   **Disable Preflight:** Ensure Tailwind's `preflight` is disabled (`corePlugins: { preflight: false }` in `tailwind.config.js`) to prevent base style conflicts.
    *   **Prioritize Chakra:** Use Chakra style props/`sx` over Tailwind utility classes for component-specific styling.
    *   **Limited Utilities:** Use Tailwind utility classes (`className`) sparingly, primarily for layout or simple spacing/typography where Chakra props are less convenient. Be aware they can still cause conflicts. (Alternative: Consider enforcing a Tailwind prefix if utilities are used extensively).
    *   **Avoid Tailwind Components:** Do not use `@tailwind components;` if relying on Chakra components, to minimize conflicts.

## 3. Prompt Engineering Principles

1. **Instruction Clarity**:
   - Be explicit about functional requirements without being domain-specific
   - Include examples that demonstrate patterns, not specific implementations
   - Request initialization, validation, and error handling for all components
   - Ensure prompt examples strictly follow the latest Chakra UI v3 component names, prop names (`colorPalette`, `disabled`), and styling conventions (`sx` for overrides).

2. **Balance**:
   - Guide the AI without constraining its creativity
   - Provide enough structure for functionality without dictating domain-specific logic
   - Use examples that can be applied across multiple domains and use cases

## 4. Testing and Validation

1. **Generic Testing**:
   - Test for functionality patterns, not specific domain behaviors
   - Verify components work together without assuming specific use cases
   - Validate that error handling works across all component interactions
   - Test components under different conditions (e.g., light/dark mode) to identify potential style conflicts arising from external CSS or utility libraries.

2. **Continuous Improvement**:
   - Use feedback to improve prompts and components, not to add domain-specific logic
   - Learn from successful generations to identify universal patterns
   - Apply improvements systematically across the entire system

## 5. Development Safeguards

1. **Principle Protection**:
   - Flag and reject any proposals that introduce domain-specific or use case-specific logic
   - Challenge assumptions that restrict the AI's creative freedom
   - Always prioritize flexibility over specialized functionality

2. **Performance Awareness**:
   - Reject changes that would significantly slow generation speed
   - Favor lightweight solutions over complex processing
   - Be mindful of token consumption in prompts and responses
   - Balance functionality with performance to maintain responsiveness

3. **Directional Guidance**:
   - Provide constructive alternatives when rejecting problematic suggestions
   - Clearly explain when proposals contradict Morpheo's core principles
   - Suggest course corrections that align better with the AI-driven approach

## 6. Component Development Best Practices

1. **Search Before Creating**:
   - Always search for existing components before creating new ones
   - Review component registry to understand available building blocks
   - Leverage existing implementations rather than duplicating functionality

2. **Semantic Consistency**:
   - Use consistent naming conventions for similar functions
   - Maintain predictable property and method signatures
   - Document component interfaces clearly

3. **Progressive Enhancement**:
   - Build for base functionality first, then add advanced features
   - Ensure graceful degradation when features aren't available
   - Layer complexity incrementally to maintain reliability

## 7. AI Prompt Enhancement Strategy

1. **Context Maximization**:
   - Provide clear examples of pattern implementation
   - Include common anti-patterns to avoid
   - Demonstrate reusable techniques that work across many domains

2. **Comprehensive Documentation**:
   - Document component capabilities, limitations and integration patterns
   - Include expected behaviors and failure modes
   - Provide clear guidance on component composition
   - Regularly review and update the embedded component/prop documentation within the AI prompt (`gemini_prompt_template.md`) to match the current Chakra UI version and project conventions.

3. **Guidance Without Restriction**:
   - Suggest approaches without requiring specific implementations
   - Emphasize desired outcomes over particular coding techniques
   - Balance structure with creative freedom

Remember: The system provides only the tools and framework - the AI provides the domain logic. When in doubt, prioritize flexibility, speed, and AI-driven solutions over hardcoded behaviors. Never create components that serve only a single use case (like BitcoinChart, TodoList, or WeatherWidget) - instead, create generic components the AI can apply to any domain. 