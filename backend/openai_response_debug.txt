--- Prompt Sent ---
# Morpheo AI UI Generation Prompt

## Core Task

Generate **only the body** of a React functional component (hooks, handlers, return statement) **using plain JavaScript** that implements the user's request using Chakra UI v3 components. The output should be ready to be inserted into `const MyComponent = () => { /* HERE */ };` and rendered via react-live.

## Input

- **User Request:** (User's natural language description of the desired UI/functionality)
- **Current App State (Optional):** (JSON representation of relevant state variables, if provided)
- **Target File/Component Name (Optional):** (Suggested name for the generated component)

## Output Requirements

- **Format:** Valid **plain JavaScript** code representing the *inside* of a React functional component (hooks, logic, `return (...)` statement). **Do not** include the surrounding `const MyComponent = () => { ... };` definition. **Do not** wrap the code in markdown fences (```).
- **Imports:** **Do NOT** include `import React...` or `import { ... } from \'@chakra-ui/react\'` statements. Assume `React` and all Chakra UI components/hooks are available in the execution scope.
- **Component Definition:** **Do NOT** define the component function (e.g., `const MyGeneratedComponent = (props) => { ... };`). Output only the content that goes *inside* such a function.
- **Props:** Assume props are destructured from the first argument if needed (e.g., `{ prop1, prop2 }`). Mention in comments if props are expected.
- **Chakra UI Usage:**
    - Use **only** Chakra UI v3 components (referencing the provided `llms-full.txt` documentation).
    - Adhere strictly to v3 component names (e.g., `Field`, `Dialog`) and prop names (`colorPalette`, `disabled`, `invalid`, `required`, `open`). **Do not use** removed v3 props like `isDisabled`, `isInvalid`, `colorScheme`.
    - Apply styling primarily using Chakra UI **style props** (e.g., `bg`, `p`, `color`, `fontSize`). Use theme tokens (e.g., `"blue.500"`).
    - Use the `sx` prop **only** for complex styles (e.g., gradients, overrides) or where style props are insufficient. Reference theme tokens via `token()` if needed within `sx`.
    - **Do not** use `@chakra-ui/icons` or icon-related props (`leftIcon`, `rightIcon`, etc.). If icons are needed, use placeholder text or a generic `Icon` component if available *without* the separate icon library.
- **State Management:**
    - Use standard React hooks (`useState`, `useEffect`, `useCallback`, `useRef`) for internal component state. **Use plain JavaScript (no TypeScript generics like useState<string>)**.
    - Manage shared state by accepting state variables and setter functions via props (e.g., `appState`, `setAppState`) or using React Context if appropriate for the complexity.
    - **Do not** use custom state management expressions like `$state` or `$setState`.
- **Event Handling:**
    - Use standard React event handlers (e.g., `onClick`, `onChange`).
    - Implement event logic directly within inline arrow functions or separate handler functions defined within the component.
    - If interacting with shared state, call the appropriate setter function received via props.
    - **Do not** use custom action expressions like `$eval` or `$morpheo.functionName()`.
- **Dynamic Values/Rendering:**
    - Use standard JavaScript expressions directly within JSX (e.g., `{variable}`, `{condition ? \'A\' : \'B\'}`, `{array.map(...) }`).
    - **Do not** use custom expression objects like `$if`, `$map`, `$eq`.
- **Code Quality:**
    - Generate clean, readable, and well-formatted **JavaScript** code.
    - Ensure basic accessibility practices (e.g., appropriate HTML semantics via Chakra components, label association if using `Field`).
- **No Domain Logic:** The generated component must contain **only** UI presentation and interaction logic. All business/domain-specific logic must be handled outside this component (presumably by the system calling the AI or through functions passed as props).
- **No Render Call:** **Do NOT** include a `render()` call at the end of the component code.

## Example Input

User Request: "Create a simple counter component with a number display and two buttons: one to increment and one to decrement the count. The initial count should be 0."

## Example Output (Illustrative - Plain JavaScript Component Body)

```javascript
// No imports needed - React and Chakra UI are in scope
// Expects no props

const [count, setCount] = useState(0); // Plain JS useState

const handleIncrement = useCallback(() => {
  setCount(prevCount => prevCount + 1);
}, []);

const handleDecrement = useCallback(() => {
  setCount(prevCount => Math.max(0, prevCount - 1));
}, []);

return (
  <VStack spacing={4} p={5} borderWidth={1} borderRadius="md" boxShadow="md" bg="bg.surface">
    <Heading size="md">Simple Counter</Heading>
    <Text fontSize="2xl" fontWeight="bold" color={count > 10 ? "red.500" : "blue.500"}>
      Count: {count}
    </Text>
    <HStack spacing={3}>
      <Button colorPalette="red" onClick={handleDecrement} disabled={count === 0}>
        Decrement
      </Button>
      <Button colorPalette="green" onClick={handleIncrement}>
        Increment
      </Button>
    </HStack>
     {/* Example of conditional rendering */}
    {count > 5 && (
      <Text fontSize="sm" color="gray.500">Keep going!</Text>
    )}
  </VStack>
);

// NO const Component = ... wrapper
// NO render() call here
``` 

## User Request:

```text
a calculator 
```

--- Raw Response ---
```javascript
// Expects no props

const [displayValue, setDisplayValue] = useState("0");
const [operator, setOperator] = useState(null);
const [firstOperand, setFirstOperand] = useState(null);

const handleNumberClick = (number) => {
  setDisplayValue(displayValue === "0" ? String(number) : displayValue + number);
};

const handleOperatorClick = (nextOperator) => {
  if (firstOperand === null) {
    setFirstOperand(parseFloat(displayValue));
  } else if (operator) {
    const result = calculate(firstOperand, parseFloat(displayValue), operator);
    setDisplayValue(String(result));
    setFirstOperand(result);
  }
  setOperator(nextOperator);
  setDisplayValue("0");
};

const handleEqualsClick = () => {
  if (firstOperand && operator) {
    const result = calculate(firstOperand, parseFloat(displayValue), operator);
    setDisplayValue(String(result));
    setFirstOperand(null);
    setOperator(null);
  }
};

const handleClearClick = () => {
  setDisplayValue("0");
  setOperator(null);
  setFirstOperand(null);
};

const handleDecimalClick = () => {
  if (!displayValue.includes(".")) {
    setDisplayValue(displayValue + ".");
  }
};

const calculate = (firstOperand, secondOperand, operator) => {
  switch (operator) {
    case "+":
      return firstOperand + secondOperand;
    case "-":
      return firstOperand - secondOperand;
    case "*":
      return firstOperand * secondOperand;
    case "/":
      return firstOperand / secondOperand;
    default:
      return secondOperand;
  }
};

return (
  <VStack align="stretch" bg="gray.100" p={4} borderRadius="md" boxShadow="md">
    <Input readOnly value={displayValue} textAlign="right" fontSize="2xl" p={2} bg="white" />

    <Grid templateColumns="repeat(4, 1fr)" gap={2}>
      <Button colorPalette="gray" onClick={() => handleClearClick()}>
        AC
      </Button>
      <Button colorPalette="gray" onClick={() => handleOperatorClick("+/-")}>
        +/-
      </Button>
      <Button colorPalette="gray" onClick={() => handleOperatorClick("%")}>
        %
      </Button>
      <Button colorPalette="orange" onClick={() => handleOperatorClick("/")}>
        /
      </Button>

      <Button onClick={() => handleNumberClick(7)}>7</Button>
      <Button onClick={() => handleNumberClick(8)}>8</Button>
      <Button onClick={() => handleNumberClick(9)}>9</Button>
      <Button colorPalette="orange" onClick={() => handleOperatorClick("*")}>
        *
      </Button>

      <Button onClick={() => handleNumberClick(4)}>4</Button>
      <Button onClick={() => handleNumberClick(5)}>5</Button>
      <Button onClick={() => handleNumberClick(6)}>6</Button>
      <Button colorPalette="orange" onClick={() => handleOperatorClick("-")}>
        -
      </Button>

      <Button onClick={() => handleNumberClick(1)}>1</Button>
      <Button onClick={() => handleNumberClick(2)}>2</Button>
      <Button onClick={() => handleNumberClick(3)}>3</Button>
      <Button colorPalette="orange" onClick={() => handleOperatorClick("+")}>
        +
      </Button>

      <Button gridColumn="span 2" onClick={() => handleNumberClick(0)}>
        0
      </Button>
      <Button onClick={() => handleDecimalClick()}>.</Button>
      <Button colorPalette="orange" onClick={() => handleEqualsClick()}>
        =
      </Button>
    </Grid>
  </VStack>
);
```

--- Extracted Component Code ---
// Expects no props

const [displayValue, setDisplayValue] = useState("0");
const [operator, setOperator] = useState(null);
const [firstOperand, setFirstOperand] = useState(null);

const handleNumberClick = (number) => {
  setDisplayValue(displayValue === "0" ? String(number) : displayValue + number);
};

const handleOperatorClick = (nextOperator) => {
  if (firstOperand === null) {
    setFirstOperand(parseFloat(displayValue));
  } else if (operator) {
    const result = calculate(firstOperand, parseFloat(displayValue), operator);
    setDisplayValue(String(result));
    setFirstOperand(result);
  }
  setOperator(nextOperator);
  setDisplayValue("0");
};

const handleEqualsClick = () => {
  if (firstOperand && operator) {
    const result = calculate(firstOperand, parseFloat(displayValue), operator);
    setDisplayValue(String(result));
    setFirstOperand(null);
    setOperator(null);
  }
};

const handleClearClick = () => {
  setDisplayValue("0");
  setOperator(null);
  setFirstOperand(null);
};

const handleDecimalClick = () => {
  if (!displayValue.includes(".")) {
    setDisplayValue(displayValue + ".");
  }
};

const calculate = (firstOperand, secondOperand, operator) => {
  switch (operator) {
    case "+":
      return firstOperand + secondOperand;
    case "-":
      return firstOperand - secondOperand;
    case "*":
      return firstOperand * secondOperand;
    case "/":
      return firstOperand / secondOperand;
    default:
      return secondOperand;
  }
};

return (
  <VStack align="stretch" bg="gray.100" p={4} borderRadius="md" boxShadow="md">
    <Input readOnly value={displayValue} textAlign="right" fontSize="2xl" p={2} bg="white" />

    <Grid templateColumns="repeat(4, 1fr)" gap={2}>
      <Button colorPalette="gray" onClick={() => handleClearClick()}>
        AC
      </Button>
      <Button colorPalette="gray" onClick={() => handleOperatorClick("+/-")}>
        +/-
      </Button>
      <Button colorPalette="gray" onClick={() => handleOperatorClick("%")}>
        %
      </Button>
      <Button colorPalette="orange" onClick={() => handleOperatorClick("/")}>
        /
      </Button>

      <Button onClick={() => handleNumberClick(7)}>7</Button>
      <Button onClick={() => handleNumberClick(8)}>8</Button>
      <Button onClick={() => handleNumberClick(9)}>9</Button>
      <Button colorPalette="orange" onClick={() => handleOperatorClick("*")}>
        *
      </Button>

      <Button onClick={() => handleNumberClick(4)}>4</Button>
      <Button onClick={() => handleNumberClick(5)}>5</Button>
      <Button onClick={() => handleNumberClick(6)}>6</Button>
      <Button colorPalette="orange" onClick={() => handleOperatorClick("-")}>
        -
      </Button>

      <Button onClick={() => handleNumberClick(1)}>1</Button>
      <Button onClick={() => handleNumberClick(2)}>2</Button>
      <Button onClick={() => handleNumberClick(3)}>3</Button>
      <Button colorPalette="orange" onClick={() => handleOperatorClick("+")}>
        +
      </Button>

      <Button gridColumn="span 2" onClick={() => handleNumberClick(0)}>
        0
      </Button>
      <Button onClick={() => handleDecimalClick()}>.</Button>
      <Button colorPalette="orange" onClick={() => handleEqualsClick()}>
        =
      </Button>
    </Grid>
  </VStack>
);