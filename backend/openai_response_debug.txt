--- Prompt Sent ---
# Morpheo AI UI Generation Prompt

## Core Task

Generate **only the body** of a React functional component (hooks, handlers, return statement) **using plain JavaScript** that implements the user's request using Chakra UI v3 components. The output should be ready to be inserted into `const MyComponent = () => { /* HERE */ };` and rendered via react-live.

## Input

- **User Request:** (User's natural language description of the desired UI/functionality)
- **Current App State (Optional):** (JSON representation of relevant state variables, if provided)
- **Target File/Component Name (Optional):** (Suggested name for the generated component)

## Output Requirements

- **Format:** Valid **plain JavaScript** code representing the *inside* of a React functional component (hooks, logic, `return (...)` statement). **Do not** include the surrounding `const MyComponent = () => { ... };` definition. **Do not** wrap the code in markdown fences (```).
- **Imports:** **Do NOT** include `import React...` or `import { ... } from \'@chakra-ui/react\'` statements. Assume `React` and all Chakra UI components/hooks are available in the execution scope.
- **Component Definition:** **Do NOT** define the component function (e.g., `const MyGeneratedComponent = (props) => { ... };`). Output only the content that goes *inside* such a function.
- **Props:** Assume props are destructured from the first argument if needed (e.g., `{ prop1, prop2 }`). Mention in comments if props are expected.
- **Chakra UI Usage:**
    - Use **only** Chakra UI v3 components (referencing the provided `llms-full.txt` documentation).
    - Adhere strictly to v3 component names (e.g., `Field`, `Dialog`, `Separator`) and prop names (`colorPalette`, `disabled`, `invalid`, `required`, `open`). **Do not use** removed v3 props like `isDisabled`, `isInvalid`, `colorScheme`.
    - Apply styling primarily using Chakra UI **style props** (e.g., `bg`, `p`, `color`, `fontSize`). Use theme tokens (e.g., `"blue.500"`).
    - Use the `sx` prop **only** for complex styles (e.g., gradients, overrides) or where style props are insufficient. Reference theme tokens via `token()` if needed within `sx`.
    - **Icons:** The `@chakra-ui/icons` package is **not available**. **Do NOT** attempt to import or use icons like `CheckIcon`, `EmailIcon`, etc. **Do NOT** use the `ListIcon` component. **NEVER use the `leftIcon` or `rightIcon` props on any component.** If you need an icon, use plain text (e.g., `+`, `->`) or render a generic `<Icon>` component if appropriate *without* importing a specific icon.
    - **Links:** **Do NOT** use the Chakra UI `<Link>` component. Instead, use a standard HTML `<a>` tag and apply styling using Chakra style props (e.g., `<Box as="a" href="..." color="blue.500" _hover={{ textDecoration: "underline" }}>Link Text</Box>`).
    - **Dividers:** Use the `<Separator />` component for horizontal or vertical dividers. **Do NOT** use `<Divider />`.
    - **Sliders/Carousels:** The `Slider` component is for numerical input ranges only. **Do NOT** use `Slider` or invent components like `Slide` for displaying sequences of content (e.g., testimonials, image carousels). Use `SimpleGrid`, `HStack`, or `VStack` to display such items instead.
- **State Management:**
    - Use standard React hooks (`useState`, `useEffect`, `useCallback`, `useRef`) for internal component state. **Use plain JavaScript (no TypeScript generics like useState<string>)**.
    - Manage shared state by accepting state variables and setter functions via props (e.g., `appState`, `setAppState`) or using React Context if appropriate for the complexity.
    - **Do not** use custom state management expressions like `$state` or `$setState`.
- **Event Handling:**
    - Use standard React event handlers (e.g., `onClick`, `onChange`).
    - Implement event logic directly within inline arrow functions or separate handler functions defined within the component.
    - If interacting with shared state, call the appropriate setter function received via props.
    - **Do not** use custom action expressions like `$eval` or `$morpheo.functionName()`.
- **Dynamic Values/Rendering:**
    - Use standard JavaScript expressions directly within JSX (e.g., `{variable}`, `{condition ? \'A\' : \'B\'}`, `{array.map(...) }`).
    - **Do not** use custom expression objects like `$if`, `$map`, `$eq`.
- **Code Quality:**
    - Generate clean, readable, and well-formatted **JavaScript** code.
    - Ensure basic accessibility practices (e.g., appropriate HTML semantics via Chakra components, label association if using `Field`).
- **No Domain Logic:** The generated component must contain **only** UI presentation and interaction logic. All business/domain-specific logic must be handled outside this component (presumably by the system calling the AI or through functions passed as props).
- **No Render Call:** **Do NOT** include a `render()` call at the end of the component code.

## Example Input

User Request: "Create a simple counter component with a number display and two buttons: one to increment and one to decrement the count. The initial count should be 0."

## Example Output (Illustrative - Plain JavaScript Component Body)

```javascript
// No imports needed - React and Chakra UI are in scope
// Expects no props

const [count, setCount] = useState(0); // Plain JS useState

const handleIncrement = useCallback(() => {
  setCount(prevCount => prevCount + 1);
}, []);

const handleDecrement = useCallback(() => {
  setCount(prevCount => Math.max(0, prevCount - 1));
}, []);

return (
  <VStack spacing={4} p={5} borderWidth={1} borderRadius="md" boxShadow="md" bg="bg.surface">
    <Heading size="md">Simple Counter</Heading>
    <Text fontSize="2xl" fontWeight="bold" color={count > 10 ? "red.500" : "blue.500"}>
      Count: {count}
    </Text>
    <HStack spacing={3}>
      <Button colorPalette="red" onClick={handleDecrement} disabled={count === 0}>
        Decrement
      </Button>
      <Button colorPalette="green" onClick={handleIncrement}>
        Increment
      </Button>
    </HStack>
     {/* Example of conditional rendering */}
    {count > 5 && (
      <Text fontSize="sm" color="gray.500">Keep going!</Text>
    )}
  </VStack>
);

// NO const Component = ... wrapper
// NO render() call here
``` 

## User Request:

```text
a tesseract 
```

--- Raw Response ---
```javascript
// Expects no props

const [rotation, setRotation] = useState({
  xy: 0,
  xz: 0,
  xw: 0,
  yz: 0,
  yw: 0,
  zw: 0,
});

const handleRotationChange = (axis, value) => {
  setRotation(prevRotation => ({
    ...prevRotation,
    [axis]: value,
  }));
};

// Function to calculate 4D coordinates (simplified)
const calculate4DCoordinates = (xy, xz, xw, yz, yw, zw) => {
  // Placeholder logic - replace with actual 4D rotation calculations
  // This is a highly simplified representation
  const x = Math.cos(xy) + Math.cos(xz) + Math.cos(xw);
  const y = Math.sin(xy) + Math.cos(yz) + Math.cos(yw);
  const z = Math.sin(xz) + Math.sin(yz) + Math.cos(zw);
  const w = Math.sin(xw) + Math.sin(yw) + Math.sin(zw);

  // Scale the coordinates for visibility
  const scale = 50; // Adjust the scaling factor as needed
  return { x: x * scale, y: y * scale, z: z * scale, w: w * scale };
};

const coordinates = calculate4DCoordinates(
  rotation.xy,
  rotation.xz,
  rotation.xw,
  rotation.yz,
  rotation.yw,
  rotation.zw
);

return (
  <VStack spacing={4} p={5} borderWidth={1} borderRadius="md" boxShadow="md" bg="bg.surface">
    <Heading size="md">4D Tesseract (Simplified Representation)</Heading>
    <Text>
      This is a simplified conceptualization.  A true tesseract visualization would involve significantly more complex calculations and rendering.
    </Text>
    <Box>
      <Text>Rotation (XY): {rotation.xy.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.xy} onChange={(e) => handleRotationChange('xy', parseFloat(e.target.value))} />
    </Box>
    <Box>
      <Text>Rotation (XZ): {rotation.xz.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.xz} onChange={(e) => handleRotationChange('xz', parseFloat(e.target.value))} />
    </Box>
     <Box>
      <Text>Rotation (XW): {rotation.xw.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.xw} onChange={(e) => handleRotationChange('xw', parseFloat(e.target.value))} />
    </Box>
    <Box>
      <Text>Rotation (YZ): {rotation.yz.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.yz} onChange={(e) => handleRotationChange('yz', parseFloat(e.target.value))} />
    </Box>
    <Box>
      <Text>Rotation (YW): {rotation.yw.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.yw} onChange={(e) => handleRotationChange('yw', parseFloat(e.target.value))} />
    </Box>
     <Box>
      <Text>Rotation (ZW): {rotation.zw.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.zw} onChange={(e) => handleRotationChange('zw', parseFloat(e.target.value))} />
    </Box>

    <Text>Calculated Coordinates:</Text>
    <Text>X: {coordinates.x.toFixed(2)}</Text>
    <Text>Y: {coordinates.y.toFixed(2)}</Text>
    <Text>Z: {coordinates.z.toFixed(2)}</Text>
    <Text>W: {coordinates.w.toFixed(2)}</Text>

    <Text color="gray.500" fontSize="sm">
      Note: This is a vastly simplified demonstration. Real 4D rendering is beyond the scope of this example.
    </Text>
  </VStack>
);
```

--- Extracted Component Code ---
// Expects no props

const [rotation, setRotation] = useState({
  xy: 0,
  xz: 0,
  xw: 0,
  yz: 0,
  yw: 0,
  zw: 0,
});

const handleRotationChange = (axis, value) => {
  setRotation(prevRotation => ({
    ...prevRotation,
    [axis]: value,
  }));
};

// Function to calculate 4D coordinates (simplified)
const calculate4DCoordinates = (xy, xz, xw, yz, yw, zw) => {
  // Placeholder logic - replace with actual 4D rotation calculations
  // This is a highly simplified representation
  const x = Math.cos(xy) + Math.cos(xz) + Math.cos(xw);
  const y = Math.sin(xy) + Math.cos(yz) + Math.cos(yw);
  const z = Math.sin(xz) + Math.sin(yz) + Math.cos(zw);
  const w = Math.sin(xw) + Math.sin(yw) + Math.sin(zw);

  // Scale the coordinates for visibility
  const scale = 50; // Adjust the scaling factor as needed
  return { x: x * scale, y: y * scale, z: z * scale, w: w * scale };
};

const coordinates = calculate4DCoordinates(
  rotation.xy,
  rotation.xz,
  rotation.xw,
  rotation.yz,
  rotation.yw,
  rotation.zw
);

return (
  <VStack spacing={4} p={5} borderWidth={1} borderRadius="md" boxShadow="md" bg="bg.surface">
    <Heading size="md">4D Tesseract (Simplified Representation)</Heading>
    <Text>
      This is a simplified conceptualization.  A true tesseract visualization would involve significantly more complex calculations and rendering.
    </Text>
    <Box>
      <Text>Rotation (XY): {rotation.xy.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.xy} onChange={(e) => handleRotationChange('xy', parseFloat(e.target.value))} />
    </Box>
    <Box>
      <Text>Rotation (XZ): {rotation.xz.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.xz} onChange={(e) => handleRotationChange('xz', parseFloat(e.target.value))} />
    </Box>
     <Box>
      <Text>Rotation (XW): {rotation.xw.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.xw} onChange={(e) => handleRotationChange('xw', parseFloat(e.target.value))} />
    </Box>
    <Box>
      <Text>Rotation (YZ): {rotation.yz.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.yz} onChange={(e) => handleRotationChange('yz', parseFloat(e.target.value))} />
    </Box>
    <Box>
      <Text>Rotation (YW): {rotation.yw.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.yw} onChange={(e) => handleRotationChange('yw', parseFloat(e.target.value))} />
    </Box>
     <Box>
      <Text>Rotation (ZW): {rotation.zw.toFixed(2)}</Text>
      <Input type="range" min="0" max="6.28" step="0.01" value={rotation.zw} onChange={(e) => handleRotationChange('zw', parseFloat(e.target.value))} />
    </Box>

    <Text>Calculated Coordinates:</Text>
    <Text>X: {coordinates.x.toFixed(2)}</Text>
    <Text>Y: {coordinates.y.toFixed(2)}</Text>
    <Text>Z: {coordinates.z.toFixed(2)}</Text>
    <Text>W: {coordinates.w.toFixed(2)}</Text>

    <Text color="gray.500" fontSize="sm">
      Note: This is a vastly simplified demonstration. Real 4D rendering is beyond the scope of this example.
    </Text>
  </VStack>
);