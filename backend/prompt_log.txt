--- Prompt at 2025-04-11 22:17:42.812983 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple calculator
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:18:19.349593 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:25:51.708650 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:39:53.285658 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:43:27.637210 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:47:13.753209 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:50:59.564967 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:57:19.233918 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 05:42:08.312030 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:13:58.118318 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:14:36.214954 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:29:07.397971 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:33:51.456665 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:39:19.604065 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 07:27:04.083363 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a odo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 07:28:06.692056 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 18:43:01.108613 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 18:46:36.900191 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 18:52:40.223168 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:10:16.216529 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:13:36.891167 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:16:07.290410 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:20:09.811748 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:25:00.593633 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:28:21.709318 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:30:44.008579 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:33:03.543031 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:40:05.371990 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:45:15.141048 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:47:38.849007 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:54:47.720434 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:55:21.293455 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:55:44.286021 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:13:54.369004 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:16:58.893616 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:23:46.206962 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:28:17.701117 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 21:49:23.687402 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 21:52:11.578605 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 21:52:47.211608 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a professional looking todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:21:56.673583 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:22:58.955530 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:24:39.562509 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:35:28.526351 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:39:16.185274 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:42:05.997975 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:17:37.455370 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:39:29.746292 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:42:50.039224 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:45:37.137907 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:38:51.521787 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:45:26.412696 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:46:01.303377 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:50:35.847955 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:20:49.959973 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:21:32.342934 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:42:26.735040 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:44:07.182096 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:50:43.004341 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:56:18.798945 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:59:47.443484 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:04:31.920272 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:24:15.324813 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:26:58.443091 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:28:12.060667 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:28:43.061759 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:29:03.656195 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:29:35.274521 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:29:56.383354 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:36:10.561906 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:38:55.982729 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:44:24.980428 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:53:05.538366 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:55:25.340586 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:03:17.460329 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:05:08.030104 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:07:25.430089 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:08:24.304801 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:10:48.687592 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:12:25.179759 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:17:33.189198 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:22:57.894189 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:26:14.733943 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:36:03.874841 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:38:23.872620 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:40:14.823613 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:32:45.981490 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:36:21.472222 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:37:11.648703 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:39:53.566935 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:15:35.261048 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:20:05.215264 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:20:51.317907 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:26:59.242744 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:27:02.536947 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:31:39.120171 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:42.257696 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:46.310612 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:50.708213 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:53.586641 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:56.350230 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:59.010484 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:02.257655 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:05.254493 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:09.465085 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:11.912304 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:14.988203 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:26.077172 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:29.430468 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:32.718347 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:35.675607 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:38.733513 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:42.149536 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:44.875810 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:48.606091 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:52.060179 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:55.756604 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:59.105255 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:02.804936 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:31.370995 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:34.966705 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:38.331993 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:30:47.081090 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:38:59.449451 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:41:46.917540 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:50:54.830610 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:09:21.707834 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:34:05.211195 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:40:17.077022 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:41:54.928001 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:47:43.209085 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 09:18:54.169763 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 09:24:11.038279 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:38:29.266560 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:44:57.796989 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:47:26.914556 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:53:58.890209 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:59:16.120846 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 12:11:11.039866 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 12:18:06.606486 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 13:10:20.361872 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 18:41:53.282010 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-16 10:08:08.186261 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:08:26.004650 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:13:04.856053 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:21:13.079681 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:22:06.449768 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:22:20.301129 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:22:35.742936 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:27:11.273886 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:34:10.928160 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:38:39.496898 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:45:23.137309 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:49:28.442342 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:51:31.065546 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: reate an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:53:37.426575 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:54:58.307792 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Create a dropdown menu with options 'Option A', 'Option B', 'Option C', and a text area below it. When an option is selected from the dropdown, display the selected option's text in the text area.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:56:36.871070 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Build an interface with two text input fields and a button labeled 'Combine'. When the button is clicked, display the text from both input fields joined together in a separate text area below.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 12:36:22.657132 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 12:46:53.892395 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:31:37.807557 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:32:59.722191 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:33:32.925539 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:34:00.991163 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:35:40.167656 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:37:02.615544 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:39:20.364837 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:40:10.608219 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:43:33.547381 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:46:00.720345 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:00:52.406074 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:11:55.962027 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:12:13.480011 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:16:05.337902 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:16:39.884035 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:29:48.789883 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:30:20.182244 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:40:16.981809 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:45:06.073007 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:52:17.343965 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 16:06:49.604318 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 16:19:43.888275 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:02:31.939475 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:06:16.370579 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:07:10.607965 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:10:29.819725 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:12:39.566513 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:17:58.394937 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:21:06.757758 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:23:13.212719 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:28:48.688934 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:38:45.246228 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:41:18.708092 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:44:28.062426 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:49:36.056534 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), a variable name (`"$varName"`), OR **a conditional object for toggling**:
      ```json
      // Example: Conditional object for toggling
      { 
        "condition": "$currentValue === 'someState'", // A string condition comparing a variable
        "trueValue": "newState",                   // Value if condition is true
        "falseValue": "oldState"                   // Value if condition is false
      }
      ```
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    // Example using conditional newValue to toggle a style:
    { 
      "type": "SET_PROPERTY", 
      "targetId": "some-element", 
      "propertyName": "styles.fontWeight", 
      "newValue": { 
        "condition": "$currentWeight === 'normal'", 
        "trueValue": "bold", 
        "falseValue": "normal" 
      } 
    }
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style (e.g., Bold Text)**
This pattern uses `GET_PROPERTY` to read the current state and a conditional `SET_PROPERTY` to toggle a style based on that state.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    { 
      "type": "GET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Get the specific style property
      "resultVariable": "currentWeight" 
    },
    { 
      "type": "LOG_MESSAGE", // Optional: for debugging
      "message": "Current weight: $currentWeight"
    },
    { 
      "type": "SET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Set the same style property
      "newValue": { // Use conditional object for toggling
        "condition": "$currentWeight === 'normal'", // Check the fetched value
        "trueValue": "bold",                     // Value if condition is true
        "falseValue": "normal"                   // Value if condition is false
      }
    }
    // Optional: Update button text based on new state
    // { 
    //   "type": "SET_PROPERTY", 
    //   "targetId": "toggle-bold-button", 
    //   "propertyName": "content", 
    //   "newValue": { 
    //     "condition": "$currentWeight === 'normal'", // Use the *original* weight here
    //     "trueValue": "Make Normal", 
    //     "falseValue": "Make Bold" 
    //   } 
    // }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:53:27.420062 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), a variable name (`"$varName"`), OR **a conditional object for toggling**:
      ```json
      // Example: Conditional object for toggling
      { 
        "condition": "$currentValue === 'someState'", // A string condition comparing a variable
        "trueValue": "newState",                   // Value if condition is true
        "falseValue": "oldState"                   // Value if condition is false
      }
      ```
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    // Example using conditional newValue to toggle a style:
    { 
      "type": "SET_PROPERTY", 
      "targetId": "some-element", 
      "propertyName": "styles.fontWeight", 
      "newValue": { 
        "condition": "$currentWeight === 'normal'", 
        "trueValue": "bold", 
        "falseValue": "normal" 
      } 
    }
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style (e.g., Bold Text)**
This pattern uses `GET_PROPERTY` to read the current state and a conditional `SET_PROPERTY` to toggle a style based on that state.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    { 
      "type": "GET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Get the specific style property
      "resultVariable": "currentWeight" 
    },
    { 
      "type": "LOG_MESSAGE", // Optional: for debugging
      "message": "Current weight: $currentWeight"
    },
    { 
      "type": "SET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Set the same style property
      "newValue": { // Use conditional object for toggling
        "condition": "$currentWeight === 'normal'", // Check the fetched value
        "trueValue": "bold",                     // Value if condition is true
        "falseValue": "normal"                   // Value if condition is false
      }
    }
    // Optional: Update button text based on new state
    // { 
    //   "type": "SET_PROPERTY", 
    //   "targetId": "toggle-bold-button", 
    //   "propertyName": "content", 
    //   "newValue": { 
    //     "condition": "$currentWeight === 'normal'", // Use the *original* weight here
    //     "trueValue": "Make Normal", 
    //     "falseValue": "Make Bold" 
    //   } 
    // }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:59:29.822625 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), a variable name (`"$varName"`), OR **a conditional object for toggling**:
      ```json
      // Example: Conditional object for toggling
      { 
        "condition": "$currentValue === 'someState'", // A string condition comparing a variable
        "trueValue": "newState",                   // Value if condition is true
        "falseValue": "oldState"                   // Value if condition is false
      }
      ```
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    // Example using conditional newValue to toggle a style:
    { 
      "type": "SET_PROPERTY", 
      "targetId": "some-element", 
      "propertyName": "styles.fontWeight", 
      "newValue": { 
        "condition": "$currentWeight === 'normal'", 
        "trueValue": "bold", 
        "falseValue": "normal" 
      } 
    }
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style (e.g., Bold Text)**
This pattern uses `GET_PROPERTY` to read the current state and a conditional `SET_PROPERTY` to toggle a style based on that state.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    { 
      "type": "GET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Get the specific style property
      "resultVariable": "currentWeight" 
    },
    { 
      "type": "LOG_MESSAGE", // Optional: for debugging
      "message": "Current weight: $currentWeight"
    },
    { 
      "type": "SET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Set the same style property
      "newValue": { // Use conditional object for toggling
        "condition": "$currentWeight === 'normal'", // Check the fetched value
        "trueValue": "bold",                     // Value if condition is true
        "falseValue": "normal"                   // Value if condition is false
      }
    }
    // Optional: Update button text based on new state
    // { 
    //   "type": "SET_PROPERTY", 
    //   "targetId": "toggle-bold-button", 
    //   "propertyName": "content", 
    //   "newValue": { 
    //     "condition": "$currentWeight === 'normal'", // Use the *original* weight here
    //     "trueValue": "Make Normal", 
    //     "falseValue": "Make Bold" 
    //   } 
    // }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:06:08.624610 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), a variable name (`"$varName"`), OR **a conditional object for toggling**:
      ```json
      // Example: Conditional object for toggling
      { 
        "condition": "$currentValue === 'someState'", // A string condition comparing a variable
        "trueValue": "newState",                   // Value if condition is true
        "falseValue": "oldState"                   // Value if condition is false
      }
      ```
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    // Example using conditional newValue to toggle a style:
    { 
      "type": "SET_PROPERTY", 
      "targetId": "some-element", 
      "propertyName": "styles.fontWeight", 
      "newValue": { 
        "condition": "$currentWeight === 'normal'", 
        "trueValue": "bold", 
        "falseValue": "normal" 
      } 
    }
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style (e.g., Bold Text)**
This pattern uses `GET_PROPERTY` to read the current state and a conditional `SET_PROPERTY` to toggle a style based on that state.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    { 
      "type": "GET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Get the specific style property
      "resultVariable": "currentWeight" 
    },
    { 
      "type": "LOG_MESSAGE", // Optional: for debugging
      "message": "Current weight: $currentWeight"
    },
    { 
      "type": "SET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Set the same style property
      "newValue": { // Use conditional object for toggling
        "condition": "$currentWeight === 'normal'", // Check the fetched value
        "trueValue": "bold",                     // Value if condition is true
        "falseValue": "normal"                   // Value if condition is false
      }
    }
    // Optional: Update button text based on new state
    // { 
    //   "type": "SET_PROPERTY", 
    //   "targetId": "toggle-bold-button", 
    //   "propertyName": "content", 
    //   "newValue": { 
    //     "condition": "$currentWeight === 'normal'", // Use the *original* weight here
    //     "trueValue": "Make Normal", 
    //     "falseValue": "Make Bold" 
    //   } 
    // }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:23:22.102708 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:29:42.038066 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:33:57.391619 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:36:43.241172 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:37:22.392111 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style. The font should sans roman
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:37:42.810528 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:42:54.878928 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:44:27.534344 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:47:21.240213 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:10:44.571169 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:14:13.960181 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text red and bold, and clicking again should remove the bold style and text to black.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:19:30.432073 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create a simple app with:
    1. A text component with id "info-text" displaying "Initial Value".
    2. A button component with id "log-button" and text "Log Content".
    3. When "log-button" is clicked, it should get the 'content' property from "info-text", store it in a variable named 'currentContent', and then log the message "The current content is: $currentContent" to the console. Use IR for the button's click method.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:21:47.513102 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create a simple app with:
    1. A text component with id "info-text" displaying "Initial Value".
    2. A button component with id "log-button" and text "Log Content".
    3. When "log-button" is clicked, it should get the 'content' property from "info-text", store it in a variable named 'currentContent', and then log the message "The current content is: $currentContent" to the console. Use IR for the button's click method.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:23:33.069588 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an application with:
    1. A text-input component with id "user-input" and placeholder "Enter text here".
    2. A text component with id "display-text" initially showing "Waiting for input...".
    3. A button component with id "update-button" and text "Update Display".
    4. When "update-button" is clicked, use IR to:
       a. Get the 'value' property from "user-input" and store it in a variable 'inputValue'.
       b. Set the 'content' property of "display-text" to the value stored in '$inputValue'.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:26:37.369287 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:27:04.549058 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:27:37.586316 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 06:53:10.009564 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 06:55:30.385903 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:03:25.900310 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:05:43.079660 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:18:48.521412 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Build a simple counter app. It should have:
    1. A text display (id: "count-display") showing "Count: 0" initially.
    2. An 'Increment' button (id: "increment-btn").
    3. When the 'Increment' button is clicked, the number in the "count-display" text should increase by 1. Use IR for the button's click method.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:19:38.682047 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Build a simple counter app. It should have:
    1. A text display (id: "count-display") showing "Count: 0" initially.
    2. An 'Increment' button (id: "increment-btn").
    3. When the 'Increment' button is clicked, the number in the "count-display" text should increase by 1. Use IR for the button's click method.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:26:49.721294 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:27:19.311358 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:33:42.900811 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:40:15.999889 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:43:34.120563 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:52:32.596997 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:53:36.305379 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:54:28.788890 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:01:36.638378 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:04:45.330718 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:16:24.635012 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:23:44.852844 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:24:15.069652 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:29:16.746760 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:50:44.194266 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:51:17.875732 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:52:20.078710 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:53:20.052878 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic but functional todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:54:11.191255 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:56:07.714962 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:03:22.761399 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:04:53.852462 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:05:27.957456 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:06:10.674372 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:06:44.834097 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:07:23.414919 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:32:20.493365 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:32:55.855653 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:33:43.536054 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:23:40.356973 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:24:25.362274 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:31:52.131579 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:33:18.779277 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:34:08.476495 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

