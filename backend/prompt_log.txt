--- Prompt at 2025-04-11 22:17:42.812983 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple calculator
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:18:19.349593 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:25:51.708650 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:39:53.285658 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:43:27.637210 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:47:13.753209 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:50:59.564967 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:57:19.233918 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 05:42:08.312030 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:13:58.118318 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:14:36.214954 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:29:07.397971 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:33:51.456665 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:39:19.604065 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 07:27:04.083363 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a odo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 07:28:06.692056 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 18:43:01.108613 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 18:46:36.900191 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 18:52:40.223168 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:10:16.216529 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:13:36.891167 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:16:07.290410 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:20:09.811748 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:25:00.593633 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:28:21.709318 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:30:44.008579 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:33:03.543031 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:40:05.371990 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:45:15.141048 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:47:38.849007 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:54:47.720434 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:55:21.293455 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:55:44.286021 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:13:54.369004 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:16:58.893616 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:23:46.206962 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:28:17.701117 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 21:49:23.687402 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 21:52:11.578605 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 21:52:47.211608 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a professional looking todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:21:56.673583 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:22:58.955530 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:24:39.562509 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:35:28.526351 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:39:16.185274 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:42:05.997975 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:17:37.455370 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:39:29.746292 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:42:50.039224 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:45:37.137907 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:38:51.521787 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:45:26.412696 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:46:01.303377 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:50:35.847955 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:20:49.959973 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:21:32.342934 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:42:26.735040 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:44:07.182096 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:50:43.004341 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:56:18.798945 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:59:47.443484 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:04:31.920272 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:24:15.324813 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:26:58.443091 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:28:12.060667 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:28:43.061759 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:29:03.656195 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:29:35.274521 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:29:56.383354 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:36:10.561906 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:38:55.982729 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:44:24.980428 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:53:05.538366 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:55:25.340586 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:03:17.460329 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:05:08.030104 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:07:25.430089 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:08:24.304801 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:10:48.687592 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:12:25.179759 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:17:33.189198 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:22:57.894189 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:26:14.733943 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:36:03.874841 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:38:23.872620 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:40:14.823613 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:32:45.981490 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:36:21.472222 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:37:11.648703 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:39:53.566935 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:15:35.261048 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:20:05.215264 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:20:51.317907 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:26:59.242744 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:27:02.536947 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:31:39.120171 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:42.257696 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:46.310612 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:50.708213 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:53.586641 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:56.350230 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:59.010484 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:02.257655 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:05.254493 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:09.465085 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:11.912304 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:14.988203 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:26.077172 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:29.430468 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:32.718347 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:35.675607 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:38.733513 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:42.149536 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:44.875810 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:48.606091 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:52.060179 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:55.756604 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:59.105255 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:02.804936 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:31.370995 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:34.966705 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:38.331993 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:30:47.081090 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:38:59.449451 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:41:46.917540 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:50:54.830610 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:09:21.707834 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:34:05.211195 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:40:17.077022 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:41:54.928001 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:47:43.209085 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 09:18:54.169763 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 09:24:11.038279 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:38:29.266560 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:44:57.796989 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:47:26.914556 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:53:58.890209 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:59:16.120846 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 12:11:11.039866 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 12:18:06.606486 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 13:10:20.361872 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 18:41:53.282010 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-16 10:08:08.186261 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:08:26.004650 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:13:04.856053 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:21:13.079681 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:22:06.449768 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:22:20.301129 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:22:35.742936 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:27:11.273886 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:34:10.928160 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:38:39.496898 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:45:23.137309 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:49:28.442342 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:51:31.065546 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: reate an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:53:37.426575 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:54:58.307792 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Create a dropdown menu with options 'Option A', 'Option B', 'Option C', and a text area below it. When an option is selected from the dropdown, display the selected option's text in the text area.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 10:56:36.871070 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Build an interface with two text input fields and a button labeled 'Combine'. When the button is clicked, display the text from both input fields joined together in a separate text area below.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 12:36:22.657132 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 12:46:53.892395 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:31:37.807557 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:32:59.722191 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:33:32.925539 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:34:00.991163 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:35:40.167656 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:37:02.615544 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:39:20.364837 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:40:10.608219 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:43:33.547381 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 14:46:00.720345 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:00:52.406074 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:11:55.962027 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:12:13.480011 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:16:05.337902 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: create an app with a text display showing 0, an 'Increment' button, and a 'Decrement' button. Clicking Increment should increase the number, and Decrement should decrease it.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:16:39.884035 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:29:48.789883 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:30:20.182244 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:40:16.981809 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:45:06.073007 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 15:52:17.343965 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 16:06:49.604318 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-16 16:19:43.888275 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:02:31.939475 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:06:16.370579 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:07:10.607965 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:10:29.819725 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:12:39.566513 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:17:58.394937 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:21:06.757758 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:23:13.212719 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:28:48.688934 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:38:45.246228 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:41:18.708092 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:44:28.062426 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`).
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean) or a variable name (string starting with `$`, e.g., `"$textFromInput"`) referencing a value stored by `GET_PROPERTY`.
    ```json
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:49:36.056534 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), a variable name (`"$varName"`), OR **a conditional object for toggling**:
      ```json
      // Example: Conditional object for toggling
      { 
        "condition": "$currentValue === 'someState'", // A string condition comparing a variable
        "trueValue": "newState",                   // Value if condition is true
        "falseValue": "oldState"                   // Value if condition is false
      }
      ```
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    // Example using conditional newValue to toggle a style:
    { 
      "type": "SET_PROPERTY", 
      "targetId": "some-element", 
      "propertyName": "styles.fontWeight", 
      "newValue": { 
        "condition": "$currentWeight === 'normal'", 
        "trueValue": "bold", 
        "falseValue": "normal" 
      } 
    }
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style (e.g., Bold Text)**
This pattern uses `GET_PROPERTY` to read the current state and a conditional `SET_PROPERTY` to toggle a style based on that state.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    { 
      "type": "GET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Get the specific style property
      "resultVariable": "currentWeight" 
    },
    { 
      "type": "LOG_MESSAGE", // Optional: for debugging
      "message": "Current weight: $currentWeight"
    },
    { 
      "type": "SET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Set the same style property
      "newValue": { // Use conditional object for toggling
        "condition": "$currentWeight === 'normal'", // Check the fetched value
        "trueValue": "bold",                     // Value if condition is true
        "falseValue": "normal"                   // Value if condition is false
      }
    }
    // Optional: Update button text based on new state
    // { 
    //   "type": "SET_PROPERTY", 
    //   "targetId": "toggle-bold-button", 
    //   "propertyName": "content", 
    //   "newValue": { 
    //     "condition": "$currentWeight === 'normal'", // Use the *original* weight here
    //     "trueValue": "Make Normal", 
    //     "falseValue": "Make Bold" 
    //   } 
    // }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:53:27.420062 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), a variable name (`"$varName"`), OR **a conditional object for toggling**:
      ```json
      // Example: Conditional object for toggling
      { 
        "condition": "$currentValue === 'someState'", // A string condition comparing a variable
        "trueValue": "newState",                   // Value if condition is true
        "falseValue": "oldState"                   // Value if condition is false
      }
      ```
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    // Example using conditional newValue to toggle a style:
    { 
      "type": "SET_PROPERTY", 
      "targetId": "some-element", 
      "propertyName": "styles.fontWeight", 
      "newValue": { 
        "condition": "$currentWeight === 'normal'", 
        "trueValue": "bold", 
        "falseValue": "normal" 
      } 
    }
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style (e.g., Bold Text)**
This pattern uses `GET_PROPERTY` to read the current state and a conditional `SET_PROPERTY` to toggle a style based on that state.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    { 
      "type": "GET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Get the specific style property
      "resultVariable": "currentWeight" 
    },
    { 
      "type": "LOG_MESSAGE", // Optional: for debugging
      "message": "Current weight: $currentWeight"
    },
    { 
      "type": "SET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Set the same style property
      "newValue": { // Use conditional object for toggling
        "condition": "$currentWeight === 'normal'", // Check the fetched value
        "trueValue": "bold",                     // Value if condition is true
        "falseValue": "normal"                   // Value if condition is false
      }
    }
    // Optional: Update button text based on new state
    // { 
    //   "type": "SET_PROPERTY", 
    //   "targetId": "toggle-bold-button", 
    //   "propertyName": "content", 
    //   "newValue": { 
    //     "condition": "$currentWeight === 'normal'", // Use the *original* weight here
    //     "trueValue": "Make Normal", 
    //     "falseValue": "Make Bold" 
    //   } 
    // }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 20:59:29.822625 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), a variable name (`"$varName"`), OR **a conditional object for toggling**:
      ```json
      // Example: Conditional object for toggling
      { 
        "condition": "$currentValue === 'someState'", // A string condition comparing a variable
        "trueValue": "newState",                   // Value if condition is true
        "falseValue": "oldState"                   // Value if condition is false
      }
      ```
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    // Example using conditional newValue to toggle a style:
    { 
      "type": "SET_PROPERTY", 
      "targetId": "some-element", 
      "propertyName": "styles.fontWeight", 
      "newValue": { 
        "condition": "$currentWeight === 'normal'", 
        "trueValue": "bold", 
        "falseValue": "normal" 
      } 
    }
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style (e.g., Bold Text)**
This pattern uses `GET_PROPERTY` to read the current state and a conditional `SET_PROPERTY` to toggle a style based on that state.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    { 
      "type": "GET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Get the specific style property
      "resultVariable": "currentWeight" 
    },
    { 
      "type": "LOG_MESSAGE", // Optional: for debugging
      "message": "Current weight: $currentWeight"
    },
    { 
      "type": "SET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Set the same style property
      "newValue": { // Use conditional object for toggling
        "condition": "$currentWeight === 'normal'", // Check the fetched value
        "trueValue": "bold",                     // Value if condition is true
        "falseValue": "normal"                   // Value if condition is false
      }
    }
    // Optional: Update button text based on new state
    // { 
    //   "type": "SET_PROPERTY", 
    //   "targetId": "toggle-bold-button", 
    //   "propertyName": "content", 
    //   "newValue": { 
    //     "condition": "$currentWeight === 'normal'", // Use the *original* weight here
    //     "trueValue": "Make Normal", 
    //     "falseValue": "Make Bold" 
    //   } 
    // }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:06:08.624610 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), a variable name (`"$varName"`), OR **a conditional object for toggling**:
      ```json
      // Example: Conditional object for toggling
      { 
        "condition": "$currentValue === 'someState'", // A string condition comparing a variable
        "trueValue": "newState",                   // Value if condition is true
        "falseValue": "oldState"                   // Value if condition is false
      }
      ```
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    // Example using conditional newValue to toggle a style:
    { 
      "type": "SET_PROPERTY", 
      "targetId": "some-element", 
      "propertyName": "styles.fontWeight", 
      "newValue": { 
        "condition": "$currentWeight === 'normal'", 
        "trueValue": "bold", 
        "falseValue": "normal" 
      } 
    }
    ```

3.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

4.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

5.  **`TOGGLE_STYLE`**: Adds/removes a specific style (e.g., for completing a task).
    - `targetId`: (string) ID of the component to style.
    - `styleName`: (string) CSS property name (e.g., `"textDecoration"`).
    - `styleValue`: (string) CSS value (e.g., `"line-through"`).
    ```json
    { "type": "TOGGLE_STYLE", "targetId": "task-item-1", "styleName": "textDecoration", "styleValue": "line-through" }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style (e.g., Bold Text)**
This pattern uses `GET_PROPERTY` to read the current state and a conditional `SET_PROPERTY` to toggle a style based on that state.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    { 
      "type": "GET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Get the specific style property
      "resultVariable": "currentWeight" 
    },
    { 
      "type": "LOG_MESSAGE", // Optional: for debugging
      "message": "Current weight: $currentWeight"
    },
    { 
      "type": "SET_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // Set the same style property
      "newValue": { // Use conditional object for toggling
        "condition": "$currentWeight === 'normal'", // Check the fetched value
        "trueValue": "bold",                     // Value if condition is true
        "falseValue": "normal"                   // Value if condition is false
      }
    }
    // Optional: Update button text based on new state
    // { 
    //   "type": "SET_PROPERTY", 
    //   "targetId": "toggle-bold-button", 
    //   "propertyName": "content", 
    //   "newValue": { 
    //     "condition": "$currentWeight === 'normal'", // Use the *original* weight here
    //     "trueValue": "Make Normal", 
    //     "falseValue": "Make Bold" 
    //   } 
    // }
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality.

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:23:22.102708 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:29:42.038066 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:33:57.391619 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:36:43.241172 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:37:22.392111 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style. The font should sans roman
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:37:42.810528 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:42:54.878928 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:44:27.534344 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 21:47:21.240213 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:10:44.571169 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text bold, and clicking again should remove the bold style.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:14:13.960181 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make an app with a line of text (e.g., 'Sample Text') and a button labeled 'Toggle Bold'. Clicking the button should make the text red and bold, and clicking again should remove the bold style and text to black.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:19:30.432073 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create a simple app with:
    1. A text component with id "info-text" displaying "Initial Value".
    2. A button component with id "log-button" and text "Log Content".
    3. When "log-button" is clicked, it should get the 'content' property from "info-text", store it in a variable named 'currentContent', and then log the message "The current content is: $currentContent" to the console. Use IR for the button's click method.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:21:47.513102 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create a simple app with:
    1. A text component with id "info-text" displaying "Initial Value".
    2. A button component with id "log-button" and text "Log Content".
    3. When "log-button" is clicked, it should get the 'content' property from "info-text", store it in a variable named 'currentContent', and then log the message "The current content is: $currentContent" to the console. Use IR for the button's click method.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:23:33.069588 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an application with:
    1. A text-input component with id "user-input" and placeholder "Enter text here".
    2. A text component with id "display-text" initially showing "Waiting for input...".
    3. A button component with id "update-button" and text "Update Display".
    4. When "update-button" is clicked, use IR to:
       a. Get the 'value' property from "user-input" and store it in a variable 'inputValue'.
       b. Set the 'content' property of "display-text" to the value stored in '$inputValue'.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:26:37.369287 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:27:04.549058 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-18 23:27:37.586316 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 06:53:10.009564 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 06:55:30.385903 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:03:25.900310 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:05:43.079660 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Create an app with:
    1. A container component with id "item-container".
    2. A button component with id "add-item-button" and text "Add Item".
    3. When "add-item-button" is clicked, use IR to execute an `ADD_COMPONENT` action that:
       a. Targets the "item-container" as the `parentId`.
       b. Provides a `config` for a new `text` component.
       c. The new text component's config should have `properties` set to `{ "content": "Newly Added Item" }`.
       d. (Optional but good practice) Include a dynamic `id` in the config, maybe using an expression like `{'type': 'EXPRESSION', 'code': "'new-item-' + Date.now()" }`.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:18:48.521412 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Build a simple counter app. It should have:
    1. A text display (id: "count-display") showing "Count: 0" initially.
    2. An 'Increment' button (id: "increment-btn").
    3. When the 'Increment' button is clicked, the number in the "count-display" text should increase by 1. Use IR for the button's click method.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:19:38.682047 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Build a simple counter app. It should have:
    1. A text display (id: "count-display") showing "Count: 0" initially.
    2. An 'Increment' button (id: "increment-btn").
    3. When the 'Increment' button is clicked, the number in the "count-display" text should increase by 1. Use IR for the button's click method.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:26:49.721294 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:27:19.311358 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:33:42.900811 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:40:15.999889 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:43:34.120563 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:52:32.596997 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:53:36.305379 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 07:54:28.788890 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:01:36.638378 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:04:45.330718 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:16:24.635012 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:23:44.852844 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:24:15.069652 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:29:16.746760 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:     Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:50:44.194266 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:51:17.875732 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:52:20.078710 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:53:20.052878 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic but functional todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:54:11.191255 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 08:56:07.714962 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:03:22.761399 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:04:53.852462 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:05:27.957456 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:06:10.674372 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:06:44.834097 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:07:23.414919 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:32:20.493365 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:32:55.855653 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 09:33:43.536054 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:23:40.356973 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:24:25.362274 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:31:52.131579 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:33:18.779277 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 10:34:08.476495 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 12:18:41.913905 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**
--- End of Prompt ---

--- Prompt at 2025-04-19 12:47:29.494364 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 12:47:38.493307 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:07:49.530780 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:35:20.036606 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:40:02.360073 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:43:58.509304 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `targetId`: (string) ID of the source component.
    - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
    - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { "type": "GET_PROPERTY", "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `targetId`: (string) ID of the target component.
    - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`). Nested properties like styles are allowed.
    - `newValue`: (any) The value to set. Can be a literal (string, number, boolean), or a variable name (`"$varName"`).
      **IMPORTANT: Do NOT use complex conditional objects here for toggling.** Use the dedicated `TOGGLE_PROPERTY` action instead (see below).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" }
    { "type": "SET_PROPERTY", "targetId": "my-input", "propertyName": "value", "newValue": "" } // Clear input
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `targetId`: (string) ID of the component whose property will be toggled.
    - `propertyName`: (string) Name of the property to toggle (e.g., `"styles.fontWeight"`, `"properties.checked"`).
    - `values`: (array) An array containing exactly two possible values to toggle between (e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] }
    // Example: Toggle a boolean property (like a checkbox state visually)
    { "type": "TOGGLE_PROPERTY", "targetId": "status-indicator", "propertyName": "properties.isActive", "values": [true, false] }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `targetId`: (string) ID of the list component.
    - `itemValue`: (any) The value to add. Can be a literal or a variable name (string starting with `$`).
    ```json
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "New List Item" }
    { "type": "ADD_ITEM", "targetId": "my-list", "itemValue": "$textFromInput" }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component (by index or value - specify details if needed).
    - `targetId`: (string) ID of the list component.
    - `itemIndex` or `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "targetId": "my-list", "itemIndex": 0 } 
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "message": "Button clicked! Input value: $inputValue" }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:49:48.655078 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:50:10.714844 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. I need an input field to type a new task, an 'Add Task' button, and a list below where the tasks appear. Each task in the list should also have a 'Delete' button next to it that removes that specific task.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:50:52.810784 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:51:31.995292 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:58:48.076775 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 13:59:20.908434 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app. 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 14:01:57.655816 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: Make me a basic todo list app.
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 14:04:12.529489 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 14:11:50.653502 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 14:21:16.195702 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 14:28:14.750357 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for:  a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 14:28:40.048561 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 15:05:56.202272 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 15:10:47.909428 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 17:17:52.502322 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 17:19:29.952510 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 17:19:43.382341 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 17:27:05.011074 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 17:29:30.651224 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 17:52:49.287151 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: No hardcoded behavior.
2. **Pure AI-Driven Generation**: You determine components and behavior.
3. **Generic Component System**: Use reusable building blocks.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs.
- Select and arrange appropriate components.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together to provide the requested functionality.
- **Infer the intended relationship between components** (e.g., an input, button, and list likely work together). **CRITICAL: Functional applications require defining `methods` using the IR for ALL interactive components.** Analyze the request and generate necessary actions (reading inputs, modifying lists/items, changing styles) for buttons, interactive list items, and inputs that drive behavior.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Instead, define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a property from a component.
    - `payload`: (object)
        - `targetId`: (string) ID of the source component.
        - `propertyName`: (string) Name of the property to read (e.g., `"value"`, `"content"`).
        - `resultVariable`: (string) Name of a temporary variable to store the result (e.g., `"inputValue"`).
    ```json
    { 
      "type": "GET_PROPERTY", 
      "payload": { 
        "targetId": "my-input", 
        "propertyName": "value", 
        "resultVariable": "textFromInput" 
      }
    }
    ```

2.  **`SET_PROPERTY`**: Writes a value to a component's property.
    - `payload`: (object)
        - `targetId`: (string) ID of the target component.
        - `propertyName`: (string) Name of the property to set (e.g., `"value"`, `"content"`, `"styles.fontWeight"`).
        - `newValue`: (any) The value to set. Can be a literal or variable (`"$varName"`).
    ```json
    // Examples:
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "" } }
    ```

3.  **`TOGGLE_PROPERTY`**: **NEW** Toggles a property between two specified values.
    - `payload`: (object)
        - `targetId`: (string) ID of the component whose property will be toggled.
        - `propertyName`: (string) Name of the property to toggle.
        - `values`: (array) An array containing exactly two values to toggle between.
    ```json
    // Example: Toggle font weight between normal and bold
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```

4.  **`ADD_ITEM`**: Adds an item to a list component's `items` property.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemValue`: (any) The value to add. Can be a literal or variable (`"$varName"`).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "New List Item" } }
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```

5.  **`REMOVE_ITEM`**: Removes an item from a list component.
    - `payload`: (object)
        - `targetId`: (string) ID of the list component.
        - `itemIndex` OR `itemValue`: (number or any) Identifier for the item to remove.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "$itemIdentifier" } }
    ```

6.  **`LOG_MESSAGE`**: Prints a message to the console (for debugging).
    - `payload`: (object)
        - `message`: (string) The message to log. Can include variables (`$varName`).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Button clicked! Input value: $inputValue" } }
    ```

**Example: Illustrating a Common Interaction Pattern**
The following demonstrates how IR actions can connect an input, button, and list. Apply this *pattern* when similar interactions are required by the user request.
For a button `add-button`, an input `item-input`, and a list `item-list`:
```json
"methods": {
  "click": [
    { "type": "GET_PROPERTY", "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" },
    { "type": "ADD_ITEM", "targetId": "item-list", "itemValue": "$newItemText" },
    { "type": "SET_PROPERTY", "targetId": "item-input", "propertyName": "value", "newValue": "" }
  ]
}
```

**Example: Toggling a Style using `TOGGLE_PROPERTY`**
This is the **preferred** pattern for toggling a property (like a style or state) between two values.
Component IDs: `toggle-bold-button` (Button), `text-display` (Text)
```json
"methods": {
  "click": [
    // No need to GET the property first, TOGGLE_PROPERTY handles it
    { 
      "type": "LOG_MESSAGE", // Optional: Log before toggle
      "message": "Toggling font weight..." 
    },
    { 
      "type": "TOGGLE_PROPERTY", 
      "targetId": "text-display", 
      "propertyName": "styles.fontWeight", // The property to toggle
      "values": ["normal", "bold"]         // The two values to cycle between
    },
    { 
      "type": "LOG_MESSAGE", // Optional: Log after toggle
      "message": "Font weight toggled." 
    }
    // Optional: Update button text based on the *intended* new state (if predictable)
    // Requires more complex logic, potentially GET after TOGGLE or separate state variable
  ]
}
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components (buttons, inputs needing validation/reaction, list items needing click/delete/toggle actions, etc.) to make the application functional. The AI *must* generate these methods based on the requested functionality. **Use `TOGGLE_PROPERTY` for simple two-state toggles instead of complex conditional logic within `SET_PROPERTY`.**

**IMPORTANT ANTI-PATTERN:** Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method. Use conditional logic *within* the *existing* IR sequence (like the conditional `newValue` object or potentially an `IF` action if more complex logic is needed) to handle state changes and toggling behavior. **Prefer `TOGGLE_PROPERTY` where applicable.**

# IMPORTANT ANTI-PATTERNS TO AVOID:

# 1. Incorrect Input onChange Handler:
  - **WRONG:** Using `GET_PROPERTY` to read the input's own value.
    ```json
    // --- INCORRECT --- DO NOT DO THIS:
    "onChange": [
      { 
        "type": "GET_PROPERTY", // WRONG ACTION for onChange!
        "payload": { "targetId": "#my-input", "propertyName": "value", "resultVariable": "val" }
      },
      { 
        "type": "SET_PROPERTY", 
        "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$val" }
      }
    ]
    ```
  - **CORRECT:** Using `GET_EVENT_DATA` to read `event.target.value`.
    ```json
    // --- CORRECT --- USE THIS PATTERN:
    "onChange": [
      { 
        "type": "GET_EVENT_DATA", // CORRECT action for onChange!
        "payload": { "path": "target.value", "resultVariable": "currentValue" } 
      },
      { 
        "type": "SET_PROPERTY", 
        "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$currentValue" }
      }
    ]
    ```

# 2. Modifying Own Methods:
   - Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method.
   - Use conditional logic *within* the *existing* IR sequence (like `TOGGLE_PROPERTY` or potentially an `IF` action) to handle state changes and toggling behavior.

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex",
    "direction": "vertical"
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // e.g., container, input, button, list
      "properties": { /* Component-specific properties, e.g., "placeholder", "content", "items" */ },
      "styles": { /* CSS-compatible styles, e.g., "padding", "color" */ },
      "methods": { 
        // CRITICAL: All interactive components MUST have methods defined!
        // For example, buttons should have a "click" method:
        "click": [
          // Array of IR action objects that execute when clicked
          { "type": "GET_PROPERTY", "targetId": "some-input", "propertyName": "value", "resultVariable": "inputValue" },
          // More actions...
        ]
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "children": [ /* Optional: Nested component objects for containers */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: Use the IR actions defined above. Implement core logic.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods.

**FINAL REQUIREMENT: ALL BUTTONS MUST HAVE A CLICK METHOD DEFINED. Input components should have appropriate methods like "change" when they need to trigger actions.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!

4. **Input components MUST handle their own value changes**:
   - Input fields (`input`, `text-input`, `textarea`) REQUIRE an `onChange` handler in `methods`.
   - This handler must use `GET_EVENT_DATA` (path: `target.value`) and `SET_PROPERTY` to update the input's own `value` property.
   - Example `onChange` IR for an input with id `my-input`:
   ```json
   "onChange": [
     { 
       "type": "GET_EVENT_DATA", 
       "path": "target.value", 
       "assignTo": "currentValue" 
     },
     { 
       "type": "SET_PROPERTY", 
       "targetId": "#my-input", 
       "propertyName": "value", 
       "value": { "type": "VARIABLE", "name": "currentValue" }
     }
   ]
   ```
--- End of Prompt ---

--- Prompt at 2025-04-19 18:23:35.876848 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior. The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs deeply.
- Select and arrange appropriate components from the list below.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together logically to provide the requested functionality.
- **CRITICAL: You MUST infer the intended relationships and interactions between components.** For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input). A functional application requires defining `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.). Analyze the request and generate all necessary IR action sequences.

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Usage Notes` for required methods and properties.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. Can be styled as needed.
    -   Properties: None specific, relies on `children` and `styles`.
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `border`, `backgroundColor`, etc. for layout and appearance.
    -   Usage Notes: The primary tool for organizing the UI structure.
-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid).
    -   Properties: `container` (boolean, true for the parent grid), `item` (boolean, true for children), `spacing` (number, multiplier for gap), `direction` ('row' or 'column'), `wrap` ('wrap' or 'nowrap').
    -   Styles: Can be styled like a container.
    -   Usage Notes: Useful for creating structured layouts with consistent spacing.
-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow.
    -   Properties: `elevation` (number, controls shadow intensity).
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Usage Notes: Good for grouping related content visually.
-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure.
    -   Properties: None specific.
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties: `content` (string, the text to display), `variant` (optional string: 'h1'-'h6', 'p', 'span', 'label' - influences semantics and potentially default styles).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`.
    -   Usage Notes: Use `variant` for semantic meaning. Content is updated via `SET_PROPERTY` targeting the `content` property.
-   **`image`**
    -   Purpose: Displays an image.
    -   Properties: `src` (string URL of the image), `alt` (string, alternative text).
    -   Styles: `width`, `height`, `objectFit` ('cover', 'contain', etc.), `borderRadius`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties: `content` (string, the text displayed on the button), `variant` (optional string for theme styling, e.g., 'primary', 'secondary').
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence to perform tasks when clicked.
-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties: `value` (string, the current text), `placeholder` (string), `label` (string, optional visible label), `type` (string, e.g., 'text', 'password', 'email', 'number').
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.change` handler using the `GET_EVENT_DATA` -> `SET_PROPERTY` pattern (see IR patterns) to manage its `value` and enable typing. The `value` property is controlled via this method.
-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string), `rows` (number).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.change` handler similar to `text-input` (using `GET_EVENT_DATA` -> `SET_PROPERTY`) to manage its `value`.
-   **`checkbox`**
    -   Purpose: A checkbox input.
    -   Properties: `label` (string), `checked` (boolean, the state of the checkbox).
    -   Styles: `margin`.
    -   Usage Notes: Requires a `methods.change` handler to toggle its `checked` state (likely using `GET_EVENT_DATA` for `target.checked` -> `SET_PROPERTY` or potentially `TOGGLE_PROPERTY` if simpler).
-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one can be selected.
    -   Properties: `options` (array of {label: string, value: string}), `value` (string, the currently selected value), `name` (string, common name for the group).
    -   Styles: Can style the container.
    -   Usage Notes: Requires `methods.change` on each radio button (if defined individually) or on the group concept to update the selected `value`.
-   **`select`**
    -   Purpose: A dropdown selection input.
    -   Properties: `label` (string), `options` (array of {value: string, label: string}), `value` (string, the currently selected value).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`.
    -   Usage Notes: Requires a `methods.change` handler (using `GET_EVENT_DATA` -> `SET_PROPERTY`) to manage its `value`.
-   **`form`**
    -   Purpose: Semantic grouping for input elements. Often used with a submit button.
    -   Properties: `submitButtonText` (string, text for a default submit button if needed).
    -   Usage Notes: Doesn't inherently handle submission; logic must be defined in a button's `click` method (e.g., getting values from multiple inputs using `GET_PROPERTY`).

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties: `items` (array, the data source for the list).
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: Items are added/removed via `ADD_ITEM`/`REMOVE_ITEM` actions targeting this component's ID. For simple string items, no template needed. For structured items, **MUST** define an `itemTemplate` object property. The `itemTemplate` defines the component structure (e.g., container, text, button) for *each* item. Use placeholders `{{item}}`, `{itemId}`, or `{{index}}` within the template's properties and method payloads. See IR patterns for examples.
-   **`datagrid`**
    -   Purpose: Displays data in a sortable, filterable table.
    -   Properties: `data` (array of objects), `columns` (array of { field: string, headerName: string }), `pagination` (boolean), `pageSize` (number), `sortable` (boolean), `filterable` (boolean).
    -   Styles: `height`, `width`.
-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data.
    -   Properties: `data` (array), `xKey` (string), `yKey` (string), `labelKey` (string), `valueKey` (string), `title` (string), etc. (Varies by chart type).
    -   Styles: `height`, `width`.

### Media

-   **`video`**
    -   Purpose: Displays video, potentially from a camera feed.
    -   Properties: `src` (string URL), `useCamera` (boolean), `facingMode` (string 'user'/'environment'), `autoPlay` (boolean), `controls` (boolean), `muted` (boolean).
    -   Styles: `width`, `height`, `objectFit`.
-   **`canvas`**
    -   Purpose: A drawing surface, often used for overlays or custom graphics.
    -   Properties: `width` (number), `height` (number).
    -   Styles: Can be styled.

### Utility

-   **`script`**
    -   Purpose: Embeds custom JavaScript (Use with extreme caution! Prefer IR methods).
    -   Properties: `content` (string of JS code) or `src` (string URL).
    -   Usage Notes: Discouraged. Most logic should be achievable via IR. Renders nothing visible.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`) maps to an **array `[]` of action objects** that execute sequentially.

**Variables:**
-   Actions like `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables using the `resultVariable` payload property.
-   Subsequent actions can use these stored values by prefixing the variable name with `$` in their `newValue` or `itemValue` payload properties (e.g., `"newValue": "$inputValue"`).
-   Variables exist only within the execution context of a single method's action sequence.

**IR Action Object Structure:**
Each object in the array has a `"type"` field specifying the action, plus parameters.

**IMPORTANT:** All parameters for an action **MUST** be nested within a `"payload"` object.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**
    -   Purpose: Reads a property value from a component's current state (properties or styles).
    -   `payload`: `targetId` (string), `propertyName` (string, e.g., `"value"`, `"content"`, `"styles.color"`), `resultVariable` (string).
    ```json
    { "type": "GET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "resultVariable": "textFromInput" } }
    ```
2.  **`GET_EVENT_DATA`**
    -   Purpose: Reads data from the triggering event object (e.g., the value of an input during `onChange`).
    -   `payload`: `path` (string, dot-notation path into the event object, e.g., `"target.value"`, `"key"`, `"target.checked"`), `resultVariable` (string).
    ```json
    { "type": "GET_EVENT_DATA", "payload": { "path": "target.value", "resultVariable": "inputValue" } }
    ```
3.  **`SET_PROPERTY`**
    -   Purpose: Writes a value to a component's property or style.
    -   `payload`: `targetId` (string), `propertyName` (string, e.g., `"value"`, `"content"`, `"styles.fontWeight"`), `newValue` (any - literal or `"$varName"`).
    ```json
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-label", "propertyName": "content", "newValue": "Updated Text" } }
    { "type": "SET_PROPERTY", "payload": { "targetId": "my-input", "propertyName": "value", "newValue": "$textFromInput" } }
    ```
4.  **`TOGGLE_PROPERTY`**
    -   Purpose: Toggles a property between two specified values. Simpler than GET -> IF -> SET for boolean/two-state toggles.
    -   `payload`: `targetId` (string), `propertyName` (string), `values` (array[2] - the two values to toggle between, e.g., `["normal", "bold"]`, `[true, false]`).
    ```json
    { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "my-text", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
    ```
5.  **`ADD_ITEM`**
    -   Purpose: Adds an item to a list component's `properties.items` array.
    -   `payload`: `targetId` (string, ID of the list component), `itemValue` (any - literal value/object or `"$varName"` to add).
    ```json
    { "type": "ADD_ITEM", "payload": { "targetId": "my-list", "itemValue": "$textFromInput" } }
    ```
6.  **`REMOVE_ITEM`**
    -   Purpose: Removes an item from a list component's `properties.items` array.
    -   `payload`: `targetId` (string, ID of the list), `itemIndex` (number, 0-based index) OR `itemValue` (any - unique identifier like `{itemId}` placeholder or `$variable`). Use only one identifier.
    ```json
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemIndex": 0 } } 
    { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "{itemId}" } } // Placeholder used in itemTemplate
    ```
7.  **`LOG_MESSAGE`**
    -   Purpose: Prints a message to the browser's developer console (for debugging).
    -   `payload`: `message` (string, can include `$varName` which will be substituted).
    ```json
    { "type": "LOG_MESSAGE", "payload": { "message": "Input value: $inputValue" } }
    ```

# --- IR USAGE PATTERNS --- #

These patterns illustrate common ways to use IR actions to build interactivity. Adapt them as needed.

## IR Pattern: Handling Input Changes (Required for `text-input`, `textarea`, `select`, `checkbox`, etc.)

# Component: `my-input` (any input type)
```json
// In methods for 'my-input', typically triggered by `change` event:
"change": [
  {
    "type": "GET_EVENT_DATA",
    "payload": {
      // Use "target.value" for text/select, "target.checked" for checkbox/radio
      "path": "target.value", 
      "resultVariable": "newValueFromEvent"
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "my-input", // Target the input itself
      // Use "value" for text/select, "checked" for checkbox/radio
      "propertyName": "value", 
      "newValue": "$newValueFromEvent" // Set property to the value from the event
    }
  }
]
```

## IR Pattern: Button Click -> Update List

# Components: `item-input` (Input), `add-button` (Button), `item-list` (List)
```json
// In methods for 'add-button':
"click": [
  { 
    "type": "GET_PROPERTY", 
    "payload": { "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" } 
  },
  { 
    "type": "ADD_ITEM", 
    "payload": { "targetId": "item-list", "itemValue": "$newItemText" } 
  },
  { 
    "type": "SET_PROPERTY", 
    "payload": { "targetId": "item-input", "propertyName": "value", "newValue": "" } // Clear input after adding
  }
]
```

## IR Pattern: Button Click -> Toggle Style

# Components: `toggle-style-button` (Button), `target-element` (any component)
```json
// In methods for 'toggle-style-button':
"click": [
  { 
    "type": "TOGGLE_PROPERTY", 
    "payload": { 
      "targetId": "target-element", 
      "propertyName": "styles.fontWeight", // Or other style/property
      "values": ["normal", "bold"]
    }
  }
]
```

## IR Pattern: List Item Interaction (Deletion)

# Component: `my-list` (List with itemTemplate containing `delete-btn-{{itemId}}`)
```json
// Within the `itemTemplate` definition for `my-list`:
{
  // ... other template elements ...
  "id": "delete-btn-{{itemId}}", // Unique ID using placeholder
  "type": "button",
  "properties": { "content": "X" },
  "methods": {
    "click": [
      {
        "type": "REMOVE_ITEM",
        "payload": {
          "targetId": "my-list",         // Target the list itself
          "itemValue": "{itemId}"         // Identify item using unique ID placeholder
        }
      }
    ]
  }
}
// ... rest of template ...
```

## IR Pattern: Simple Form Submission (Log Values)

# Components: `name-input`, `email-input`, `submit-button`
```json
// In methods for 'submit-button':
"click": [
  { 
    "type": "GET_PROPERTY", 
    "payload": { "targetId": "name-input", "propertyName": "value", "resultVariable": "nameVal" } 
  },
  { 
    "type": "GET_PROPERTY", 
    "payload": { "targetId": "email-input", "propertyName": "value", "resultVariable": "emailVal" } 
  },
  { 
    "type": "LOG_MESSAGE", 
    "payload": { "message": "Form Submitted: Name=$nameVal, Email=$emailVal" } 
  },
  // Optionally clear fields:
  { "type": "SET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "newValue": "" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Conditional Logging (Conceptual)

# Components: `status-text`, `action-button`
```json
// In methods for 'action-button':
"click": [
  { 
    "type": "GET_PROPERTY", 
    "payload": { "targetId": "status-text", "propertyName": "content", "resultVariable": "status" } 
  },
  // NOTE: An explicit IF action is not currently listed, this demonstrates the logic.
  // You would typically use SET_PROPERTY conditionally or LOG the variable directly.
  { 
    "type": "LOG_MESSAGE", 
    "payload": { "message": "Current status is: $status" } 
  }
  // To achieve conditional behavior with current actions:
  // Could potentially use SET_PROPERTY on a result display based on $status,
  // or structure subsequent actions differently if needed.
]
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components. Infer the necessary interactions from the user request and component relationships. Use the patterns above as guides. The application MUST be functional based on your generated IR.

# IMPORTANT ANTI-PATTERNS TO AVOID:

# 1. Incorrect Input onChange Handler:
  - **WRONG:** Using `GET_PROPERTY` to read the input's own value within its `onChange`.
    ```json
    // --- INCORRECT --- DO NOT DO THIS:
    "onChange": [
      { "type": "GET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "resultVariable": "val" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$val" } }
    ]
    ```
  - **CORRECT:** Using `GET_EVENT_DATA` to read `event.target.value` (or `event.target.checked` etc.).
    ```json
    // --- CORRECT --- USE THIS PATTERN:
    "onChange": [
      { "type": "GET_EVENT_DATA", "payload": { "path": "target.value", "resultVariable": "currentValue" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$currentValue" } }
    ]
    ```

# 2. Modifying Own Methods:
   - Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method.
   - Use conditional logic *within* the *existing* IR sequence (like `TOGGLE_PROPERTY`).

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex", // Or other layout types if applicable
    "direction": "vertical" // Or horizontal
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // FROM THE AVAILABLE LIST
      "properties": { /* Component-specific properties based on documentation above */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { 
        // CRITICAL: Define methods with IR actions here for ALL interactive components!
        "click": [ /* Example for a button */
          { "type": "GET_PROPERTY", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
          // ... more actions ...
        ],
        "change": [ /* Example for an input */
          { "type": "GET_EVENT_DATA", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
        ]
        // ... other methods as needed ...
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "itemTemplate": { /* ONLY for 'list' components needing structured items */ },
      "children": [ /* Optional: Nested component objects for containers/layout */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: **MANDATORY** for interactive elements. Use the IR actions defined above. Implement the core application logic here.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods connecting components.

**FINAL REQUIREMENT: ALL interactive elements (buttons, inputs, checkboxes, selects, interactive list items, etc.) MUST have appropriate methods (`click`, `change`, etc.) defined using the IR actions to ensure functionality.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!
--- End of Prompt ---

--- Prompt at 2025-04-19 18:42:54.857534 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior. The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs deeply.
- Select and arrange appropriate components from the list below.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together logically to provide the requested functionality.
- **CRITICAL: You MUST infer the intended relationships and interactions between components.** For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input). A functional application requires defining `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.). Analyze the request and generate all necessary IR action sequences.
- **COMPLETENESS:** When asked for common application types (e.g., todo list, counter, form, calculator), ensure *all standard features* are implemented using the available components and IR methods. (e.g., a todo list needs add, display, *and* delete functionality).

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Usage Notes` for required methods and properties.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. Can be styled as needed.
    -   Properties: `className` (string, for applying CSS classes).
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `border`, `backgroundColor`, etc. for layout and appearance.
    -   Usage Notes: The primary tool for organizing the UI structure. Can have its `className` updated via `SET_PROPERTY` for dynamic styling.
-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid).
    -   Properties: `container` (boolean), `item` (boolean), `spacing` (number), `direction` ('row'|'column'), `wrap` ('wrap'|'nowrap'), `className` (string).
    -   Styles: Can be styled like a container.
    -   Usage Notes: Useful for creating structured layouts with consistent spacing.
-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow.
    -   Properties: `elevation` (number), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Usage Notes: Good for grouping related content visually.
-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure.
    -   Properties: `className` (string).
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties: `content` (string), `variant` (string, optional), `className` (string).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`.
    -   Usage Notes: Use `variant` for semantic meaning. `content` is updated via `SET_PROPERTY`. `className` allows dynamic style changes.
-   **`image`**
    -   Purpose: Displays an image.
    -   Properties: `src` (string URL), `alt` (string), `className` (string).
    -   Styles: `width`, `height`, `objectFit`, `borderRadius`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties: `content` (string), `variant` (string, optional), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence.
-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string, optional), `type` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern. Can also use `keyPress`/`keyDown`/`keyUp` methods.
-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string), `rows` (number), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` similar to `text-input`.
-   **`checkbox`**
    -   Purpose: A checkbox input.
    -   Properties: `label` (string), `checked` (boolean), `disabled` (boolean), `className` (string).
    -   Styles: `margin`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.checked`) -> `SET_PROPERTY`(`propertyName`: `checked`) pattern.
-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one can be selected.
    -   Properties: `options` (array of {label: string, value: string}), `value` (string), `name` (string), `disabled` (boolean), `className` (string).
    -   Styles: Can style the container.
    -   Usage Notes: Requires `methods.change` to update the selected `value`.
-   **`select`**
    -   Purpose: A dropdown selection input.
    -   Properties: `label` (string), `options` (array of {value: string, label: string}), `value` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern.
-   **`form`**
    -   Purpose: Semantic grouping for input elements. Can potentially handle submissions.
    -   Properties: `submitButtonText` (string, optional).
    -   Usage Notes: Can have a `methods.submit` handler. Alternatively, submission logic is often placed in a button's `click` method within the form.

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties: `items` (array).
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: Items managed via `ADD_ITEM`/`REMOVE_ITEM`. For structured items, **MUST** define `itemTemplate` object property. See IR patterns.
-   **`datagrid`**
    -   Purpose: Displays data in a table.
    -   Properties: `data` (array), `columns` (array), `pagination` (boolean), `pageSize` (number), `sortable` (boolean), `filterable` (boolean).
    -   Styles: `height`, `width`.
-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data.
    -   Properties: Vary: `data`, `keys`, `title`, etc.
    -   Styles: `height`, `width`.

### Media

-   **`video`**
    -   Purpose: Displays video, optionally from camera.
    -   Properties: `src`, `useCamera`, `facingMode`, `autoPlay`, `controls`, `muted`.
    -   Styles: `width`, `height`, `objectFit`.
-   **`canvas`**
    -   Purpose: Drawing surface.
    -   Properties: `width`, `height`.

### Utility

-   **`script`**
    -   Purpose: Embeds custom JS (Discouraged! Prefer IR).
    -   Properties: `content` or `src`.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`, `"keyPress"`, `"submit"`) maps to an **array `[]` of action objects** that execute sequentially.

**Supported Events:** You can define methods for standard DOM events like `click`, `change`, `submit`, `mouseEnter`, `mouseLeave`, `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

**Variables:**
-   `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables (`resultVariable`).
-   Use `$variableName` in `newValue` or `itemValue` to access these variables in subsequent actions.
-   Variables are local to one method execution.

**IR Action Object Structure:**
-   `"type"`: Specifies the action.
-   `"payload"`: **REQUIRED** object containing all parameters for the action.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a component property/style.
    -   `payload`: `targetId`, `propertyName` (e.g., `"value"`, `"styles.color"`), `resultVariable`.
2.  **`GET_EVENT_DATA`**: Reads data from the triggering event.
    -   `payload`: `path` (e.g., `"target.value"`, `"key"`, `"target.checked"`), `resultVariable`.
3.  **`SET_PROPERTY`**: Writes a property/style.
    -   `payload`: `targetId`, `propertyName`, `newValue` (literal or `"$varName"`).
4.  **`TOGGLE_PROPERTY`**: Toggles between two values.
    -   `payload`: `targetId`, `propertyName`, `values` (array[2]).
5.  **`ADD_ITEM`**: Adds item to list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemValue` (literal/object or `"$varName"`).
6.  **`REMOVE_ITEM`**: Removes item from list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemIndex` OR `itemValue`.
7.  **`LOG_MESSAGE`**: Logs to console.
    -   `payload`: `message` (string, can include `$varName`).
8.  **`CALL_METHOD`**: Calls another component's defined IR method.
    -   `payload`: `targetId` (ID of component to call), `methodName` (string, name of method in target's `methods`), `args` (optional array of literal values or `"$varName"` to pass as arguments - **Note:** frontend support for passing/receiving args might be limited).
    ```json
    // Example: Button click calls 'increment' method on component 'counter-comp'
    { "type": "CALL_METHOD", "payload": { "targetId": "counter-comp", "methodName": "increment" } }
    ```

# --- IR USAGE PATTERNS --- #

## IR Pattern: Handling Input Changes (Required for ALL input types)

# Component: `my-input` (text-input, textarea, select, checkbox, radio-group)
```json
// In methods for 'my-input':
"change": [
  {
    "type": "GET_EVENT_DATA",
    "payload": {
      "path": "target.value", // Or "target.checked"
      "resultVariable": "newValueFromEvent"
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "my-input", 
      "propertyName": "value", // Or "checked"
      "newValue": "$newValueFromEvent"
    }
  }
]
```

## IR Pattern: Button Click -> Update List

# Components: `item-input`, `add-button`, `item-list`
```json
// In methods for 'add-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" } },
  { "type": "ADD_ITEM", "payload": { "targetId": "item-list", "itemValue": "$newItemText" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Button Click -> Toggle Style/Class

# Components: `toggle-button`, `target-element`
```json
// Toggle Style:
// In methods for 'toggle-button':
"click": [
  { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
]

// Toggle Class (Example assumes a CSS class "active" exists):
// In methods for 'toggle-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "resultVariable": "currentClass" } },
  // NOTE: Requires IF logic or helper - simplified here. Use TOGGLE_PROPERTY if possible.
  // Conceptual - actual implementation might differ based on exact frontend capabilities
  { "type": "SET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "newValue": /* Logic to add/remove 'active' based on $currentClass */ } }
]
```

## IR Pattern: List Item Interaction (Deletion)

# Component: `my-list` (List with itemTemplate)
```json
// Within the `itemTemplate` definition:
{
  "id": "delete-btn-{{itemId}}", 
  "type": "button", "properties": { "content": "X" },
  "methods": {
    "click": [
      { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "{itemId}" } }
    ]
  }
}
```

## IR Pattern: Form Submission (Log Values)

# Components: `name-input`, `email-input`, `submit-button` (or form with submit method)
```json
// In methods for 'submit-button' OR 'form.submit':
"click": [ // Or "submit"
  { "type": "GET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "resultVariable": "nameVal" } },
  { "type": "GET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "resultVariable": "emailVal" } },
  { "type": "LOG_MESSAGE", "payload": { "message": "Form Submitted: Name=$nameVal, Email=$emailVal" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "newValue": "" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Trigger Action on Enter Key

# Component: `my-input` (text-input)
```json
// In methods for 'my-input':
"keyPress": [
  { "type": "GET_EVENT_DATA", "payload": { "path": "key", "resultVariable": "pressedKey" } },
  // NOTE: Requires IF logic not currently specified in standard IR actions.
  // This pattern shows intent; actual implementation would depend on conditional support.
  // Conceptual: IF $pressedKey === 'Enter' THEN...
  { "type": "LOG_MESSAGE", "payload": { "message": "Enter key pressed! (Actual action requires IF)" } }
]
```

## IR Pattern: Calling Another Component's Method

# Components: `trigger-button`, `counter-display` (assume counter-display has an `increment` method)
```json
// In methods for 'trigger-button':
"click": [
  { "type": "LOG_MESSAGE", "payload": { "message": "Calling counter increment..." } },
  { 
    "type": "CALL_METHOD", 
    "payload": { 
      "targetId": "counter-display", 
      "methodName": "increment" 
      // "args": ["$someValue"] // Optional arguments
    } 
  }
]
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components. Infer the necessary interactions from the user request and component relationships. Use the patterns above as guides. The application MUST be functional based on your generated IR.

# IMPORTANT ANTI-PATTERNS TO AVOID:

# 1. Incorrect Input onChange Handler:
  - **WRONG:** Using `GET_PROPERTY` to read the input's own value within its `onChange`.
    ```json
    // --- INCORRECT --- DO NOT DO THIS:
    "onChange": [
      { "type": "GET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "resultVariable": "val" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$val" } }
    ]
    ```
  - **CORRECT:** Using `GET_EVENT_DATA` to read `event.target.value` (or `event.target.checked` etc.).
    ```json
    // --- CORRECT --- USE THIS PATTERN:
    "onChange": [
      { "type": "GET_EVENT_DATA", "payload": { "path": "target.value", "resultVariable": "currentValue" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$currentValue" } }
    ]
    ```

# 2. Modifying Own Methods:
   - Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method.
   - Use conditional logic *within* the *existing* IR sequence (like `TOGGLE_PROPERTY`).

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex", // Or other layout types if applicable
    "direction": "vertical" // Or horizontal
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // FROM THE AVAILABLE LIST
      "properties": { /* Component-specific properties based on documentation above */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { 
        // CRITICAL: Define methods with IR actions here for ALL interactive components!
        "click": [ /* Example for a button */
          { "type": "GET_PROPERTY", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
          // ... more actions ...
        ],
        "change": [ /* Example for an input */
          { "type": "GET_EVENT_DATA", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
        ]
        // ... other methods as needed (submit, keyPress, etc.) ...
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "itemTemplate": { /* ONLY for 'list' components needing structured items */ },
      "children": [ /* Optional: Nested component objects for containers/layout */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: **MANDATORY** for interactive elements. Use the IR actions defined above. Implement the core application logic here.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods connecting components.

**FINAL REQUIREMENT: ALL interactive elements (buttons, inputs, checkboxes, selects, interactive list items, etc.) MUST have appropriate methods (`click`, `change`, etc.) defined using the IR actions to ensure functionality.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!
--- End of Prompt ---

--- Prompt at 2025-04-19 18:44:17.343372 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a calculator
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior. The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs deeply.
- Select and arrange appropriate components from the list below.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together logically to provide the requested functionality.
- **CRITICAL: You MUST infer the intended relationships and interactions between components.** For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input). A functional application requires defining `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.). Analyze the request and generate all necessary IR action sequences.
- **COMPLETENESS:** When asked for common application types (e.g., todo list, counter, form, calculator), ensure *all standard features* are implemented using the available components and IR methods. (e.g., a todo list needs add, display, *and* delete functionality).

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Usage Notes` for required methods and properties.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. Can be styled as needed.
    -   Properties: `className` (string, for applying CSS classes).
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `border`, `backgroundColor`, etc. for layout and appearance.
    -   Usage Notes: The primary tool for organizing the UI structure. Can have its `className` updated via `SET_PROPERTY` for dynamic styling.
-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid).
    -   Properties: `container` (boolean), `item` (boolean), `spacing` (number), `direction` ('row'|'column'), `wrap` ('wrap'|'nowrap'), `className` (string).
    -   Styles: Can be styled like a container.
    -   Usage Notes: Useful for creating structured layouts with consistent spacing.
-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow.
    -   Properties: `elevation` (number), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Usage Notes: Good for grouping related content visually.
-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure.
    -   Properties: `className` (string).
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties: `content` (string), `variant` (string, optional), `className` (string).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`.
    -   Usage Notes: Use `variant` for semantic meaning. `content` is updated via `SET_PROPERTY`. `className` allows dynamic style changes.
-   **`image`**
    -   Purpose: Displays an image.
    -   Properties: `src` (string URL), `alt` (string), `className` (string).
    -   Styles: `width`, `height`, `objectFit`, `borderRadius`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties: `content` (string), `variant` (string, optional), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence.
-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string, optional), `type` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern. Can also use `keyPress`/`keyDown`/`keyUp` methods.
-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string), `rows` (number), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` similar to `text-input`.
-   **`checkbox`**
    -   Purpose: A checkbox input.
    -   Properties: `label` (string), `checked` (boolean), `disabled` (boolean), `className` (string).
    -   Styles: `margin`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.checked`) -> `SET_PROPERTY`(`propertyName`: `checked`) pattern.
-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one can be selected.
    -   Properties: `options` (array of {label: string, value: string}), `value` (string), `name` (string), `disabled` (boolean), `className` (string).
    -   Styles: Can style the container.
    -   Usage Notes: Requires `methods.change` to update the selected `value`.
-   **`select`**
    -   Purpose: A dropdown selection input.
    -   Properties: `label` (string), `options` (array of {value: string, label: string}), `value` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern.
-   **`form`**
    -   Purpose: Semantic grouping for input elements. Can potentially handle submissions.
    -   Properties: `submitButtonText` (string, optional).
    -   Usage Notes: Can have a `methods.submit` handler. Alternatively, submission logic is often placed in a button's `click` method within the form.

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties: `items` (array).
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: Items managed via `ADD_ITEM`/`REMOVE_ITEM`. For structured items, **MUST** define `itemTemplate` object property. See IR patterns.
-   **`datagrid`**
    -   Purpose: Displays data in a table.
    -   Properties: `data` (array), `columns` (array), `pagination` (boolean), `pageSize` (number), `sortable` (boolean), `filterable` (boolean).
    -   Styles: `height`, `width`.
-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data.
    -   Properties: Vary: `data`, `keys`, `title`, etc.
    -   Styles: `height`, `width`.

### Media

-   **`video`**
    -   Purpose: Displays video, optionally from camera.
    -   Properties: `src`, `useCamera`, `facingMode`, `autoPlay`, `controls`, `muted`.
    -   Styles: `width`, `height`, `objectFit`.
-   **`canvas`**
    -   Purpose: Drawing surface.
    -   Properties: `width`, `height`.

### Utility

-   **`script`**
    -   Purpose: Embeds custom JS (Discouraged! Prefer IR).
    -   Properties: `content` or `src`.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`, `"keyPress"`, `"submit"`) maps to an **array `[]` of action objects** that execute sequentially.

**Supported Events:** You can define methods for standard DOM events like `click`, `change`, `submit`, `mouseEnter`, `mouseLeave`, `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

**Variables:**
-   `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables (`resultVariable`).
-   Use `$variableName` in `newValue` or `itemValue` to access these variables in subsequent actions.
-   Variables are local to one method execution.

**IR Action Object Structure:**
-   `"type"`: Specifies the action.
-   `"payload"`: **REQUIRED** object containing all parameters for the action.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a component property/style.
    -   `payload`: `targetId`, `propertyName` (e.g., `"value"`, `"styles.color"`), `resultVariable`.
2.  **`GET_EVENT_DATA`**: Reads data from the triggering event.
    -   `payload`: `path` (e.g., `"target.value"`, `"key"`, `"target.checked"`), `resultVariable`.
3.  **`SET_PROPERTY`**: Writes a property/style.
    -   `payload`: `targetId`, `propertyName`, `newValue` (literal or `"$varName"`).
4.  **`TOGGLE_PROPERTY`**: Toggles between two values.
    -   `payload`: `targetId`, `propertyName`, `values` (array[2]).
5.  **`ADD_ITEM`**: Adds item to list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemValue` (literal/object or `"$varName"`).
6.  **`REMOVE_ITEM`**: Removes item from list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemIndex` OR `itemValue`.
7.  **`LOG_MESSAGE`**: Logs to console.
    -   `payload`: `message` (string, can include `$varName`).
8.  **`CALL_METHOD`**: Calls another component's defined IR method.
    -   `payload`: `targetId` (ID of component to call), `methodName` (string, name of method in target's `methods`), `args` (optional array of literal values or `"$varName"` to pass as arguments - **Note:** frontend support for passing/receiving args might be limited).
    ```json
    // Example: Button click calls 'increment' method on component 'counter-comp'
    { "type": "CALL_METHOD", "payload": { "targetId": "counter-comp", "methodName": "increment" } }
    ```

# --- IR USAGE PATTERNS --- #

## IR Pattern: Handling Input Changes (Required for ALL input types)

# Component: `my-input` (text-input, textarea, select, checkbox, radio-group)
```json
// In methods for 'my-input':
"change": [
  {
    "type": "GET_EVENT_DATA",
    "payload": {
      "path": "target.value", // Or "target.checked"
      "resultVariable": "newValueFromEvent"
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "my-input", 
      "propertyName": "value", // Or "checked"
      "newValue": "$newValueFromEvent"
    }
  }
]
```

## IR Pattern: Button Click -> Update List

# Components: `item-input`, `add-button`, `item-list`
```json
// In methods for 'add-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" } },
  { "type": "ADD_ITEM", "payload": { "targetId": "item-list", "itemValue": "$newItemText" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Button Click -> Toggle Style/Class

# Components: `toggle-button`, `target-element`
```json
// Toggle Style:
// In methods for 'toggle-button':
"click": [
  { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
]

// Toggle Class (Example assumes a CSS class "active" exists):
// In methods for 'toggle-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "resultVariable": "currentClass" } },
  // NOTE: Requires IF logic or helper - simplified here. Use TOGGLE_PROPERTY if possible.
  // Conceptual - actual implementation might differ based on exact frontend capabilities
  { "type": "SET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "newValue": /* Logic to add/remove 'active' based on $currentClass */ } }
]
```

## IR Pattern: List Item Interaction (Deletion)

# Component: `my-list` (List with itemTemplate)
```json
// Within the `itemTemplate` definition:
{
  "id": "delete-btn-{{itemId}}", 
  "type": "button", "properties": { "content": "X" },
  "methods": {
    "click": [
      { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "{itemId}" } }
    ]
  }
}
```

## IR Pattern: Form Submission (Log Values)

# Components: `name-input`, `email-input`, `submit-button` (or form with submit method)
```json
// In methods for 'submit-button' OR 'form.submit':
"click": [ // Or "submit"
  { "type": "GET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "resultVariable": "nameVal" } },
  { "type": "GET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "resultVariable": "emailVal" } },
  { "type": "LOG_MESSAGE", "payload": { "message": "Form Submitted: Name=$nameVal, Email=$emailVal" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "newValue": "" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Trigger Action on Enter Key

# Component: `my-input` (text-input)
```json
// In methods for 'my-input':
"keyPress": [
  { "type": "GET_EVENT_DATA", "payload": { "path": "key", "resultVariable": "pressedKey" } },
  // NOTE: Requires IF logic not currently specified in standard IR actions.
  // This pattern shows intent; actual implementation would depend on conditional support.
  // Conceptual: IF $pressedKey === 'Enter' THEN...
  { "type": "LOG_MESSAGE", "payload": { "message": "Enter key pressed! (Actual action requires IF)" } }
]
```

## IR Pattern: Calling Another Component's Method

# Components: `trigger-button`, `counter-display` (assume counter-display has an `increment` method)
```json
// In methods for 'trigger-button':
"click": [
  { "type": "LOG_MESSAGE", "payload": { "message": "Calling counter increment..." } },
  { 
    "type": "CALL_METHOD", 
    "payload": { 
      "targetId": "counter-display", 
      "methodName": "increment" 
      // "args": ["$someValue"] // Optional arguments
    } 
  }
]
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components. Infer the necessary interactions from the user request and component relationships. Use the patterns above as guides. The application MUST be functional based on your generated IR.

# IMPORTANT ANTI-PATTERNS TO AVOID:

# 1. Incorrect Input onChange Handler:
  - **WRONG:** Using `GET_PROPERTY` to read the input's own value within its `onChange`.
    ```json
    // --- INCORRECT --- DO NOT DO THIS:
    "onChange": [
      { "type": "GET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "resultVariable": "val" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$val" } }
    ]
    ```
  - **CORRECT:** Using `GET_EVENT_DATA` to read `event.target.value` (or `event.target.checked` etc.).
    ```json
    // --- CORRECT --- USE THIS PATTERN:
    "onChange": [
      { "type": "GET_EVENT_DATA", "payload": { "path": "target.value", "resultVariable": "currentValue" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$currentValue" } }
    ]
    ```

# 2. Modifying Own Methods:
   - Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method.
   - Use conditional logic *within* the *existing* IR sequence (like `TOGGLE_PROPERTY`).

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex", // Or other layout types if applicable
    "direction": "vertical" // Or horizontal
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // FROM THE AVAILABLE LIST
      "properties": { /* Component-specific properties based on documentation above */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { 
        // CRITICAL: Define methods with IR actions here for ALL interactive components!
        "click": [ /* Example for a button */
          { "type": "GET_PROPERTY", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
          // ... more actions ...
        ],
        "change": [ /* Example for an input */
          { "type": "GET_EVENT_DATA", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
        ]
        // ... other methods as needed (submit, keyPress, etc.) ...
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "itemTemplate": { /* ONLY for 'list' components needing structured items */ },
      "children": [ /* Optional: Nested component objects for containers/layout */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: **MANDATORY** for interactive elements. Use the IR actions defined above. Implement the core application logic here.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods connecting components.

**FINAL REQUIREMENT: ALL interactive elements (buttons, inputs, checkboxes, selects, interactive list items, etc.) MUST have appropriate methods (`click`, `change`, etc.) defined using the IR actions to ensure functionality.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!
--- End of Prompt ---

--- Prompt at 2025-04-19 18:45:11.682822 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple calculator
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior. The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs deeply.
- Select and arrange appropriate components from the list below.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together logically to provide the requested functionality.
- **CRITICAL: You MUST infer the intended relationships and interactions between components.** For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input). A functional application requires defining `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.). Analyze the request and generate all necessary IR action sequences.
- **COMPLETENESS:** When asked for common application types (e.g., todo list, counter, form, calculator), ensure *all standard features* are implemented using the available components and IR methods. (e.g., a todo list needs add, display, *and* delete functionality).

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Usage Notes` for required methods and properties.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. Can be styled as needed.
    -   Properties: `className` (string, for applying CSS classes).
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `border`, `backgroundColor`, etc. for layout and appearance.
    -   Usage Notes: The primary tool for organizing the UI structure. Can have its `className` updated via `SET_PROPERTY` for dynamic styling.
-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid).
    -   Properties: `container` (boolean), `item` (boolean), `spacing` (number), `direction` ('row'|'column'), `wrap` ('wrap'|'nowrap'), `className` (string).
    -   Styles: Can be styled like a container.
    -   Usage Notes: Useful for creating structured layouts with consistent spacing.
-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow.
    -   Properties: `elevation` (number), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Usage Notes: Good for grouping related content visually.
-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure.
    -   Properties: `className` (string).
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties: `content` (string), `variant` (string, optional), `className` (string).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`.
    -   Usage Notes: Use `variant` for semantic meaning. `content` is updated via `SET_PROPERTY`. `className` allows dynamic style changes.
-   **`image`**
    -   Purpose: Displays an image.
    -   Properties: `src` (string URL), `alt` (string), `className` (string).
    -   Styles: `width`, `height`, `objectFit`, `borderRadius`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties: `content` (string), `variant` (string, optional), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence.
-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string, optional), `type` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern. Can also use `keyPress`/`keyDown`/`keyUp` methods.
-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string), `rows` (number), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` similar to `text-input`.
-   **`checkbox`**
    -   Purpose: A checkbox input.
    -   Properties: `label` (string), `checked` (boolean), `disabled` (boolean), `className` (string).
    -   Styles: `margin`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.checked`) -> `SET_PROPERTY`(`propertyName`: `checked`) pattern.
-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one can be selected.
    -   Properties: `options` (array of {label: string, value: string}), `value` (string), `name` (string), `disabled` (boolean), `className` (string).
    -   Styles: Can style the container.
    -   Usage Notes: Requires `methods.change` to update the selected `value`.
-   **`select`**
    -   Purpose: A dropdown selection input.
    -   Properties: `label` (string), `options` (array of {value: string, label: string}), `value` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern.
-   **`form`**
    -   Purpose: Semantic grouping for input elements. Can potentially handle submissions.
    -   Properties: `submitButtonText` (string, optional).
    -   Usage Notes: Can have a `methods.submit` handler. Alternatively, submission logic is often placed in a button's `click` method within the form.

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties: `items` (array).
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: Items managed via `ADD_ITEM`/`REMOVE_ITEM`. For structured items, **MUST** define `itemTemplate` object property. See IR patterns.
-   **`datagrid`**
    -   Purpose: Displays data in a table.
    -   Properties: `data` (array), `columns` (array), `pagination` (boolean), `pageSize` (number), `sortable` (boolean), `filterable` (boolean).
    -   Styles: `height`, `width`.
-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data.
    -   Properties: Vary: `data`, `keys`, `title`, etc.
    -   Styles: `height`, `width`.

### Media

-   **`video`**
    -   Purpose: Displays video, optionally from camera.
    -   Properties: `src`, `useCamera`, `facingMode`, `autoPlay`, `controls`, `muted`.
    -   Styles: `width`, `height`, `objectFit`.
-   **`canvas`**
    -   Purpose: Drawing surface.
    -   Properties: `width`, `height`.

### Utility

-   **`script`**
    -   Purpose: Embeds custom JS (Discouraged! Prefer IR).
    -   Properties: `content` or `src`.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`, `"keyPress"`, `"submit"`) maps to an **array `[]` of action objects** that execute sequentially.

**Supported Events:** You can define methods for standard DOM events like `click`, `change`, `submit`, `mouseEnter`, `mouseLeave`, `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

**Variables:**
-   `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables (`resultVariable`).
-   Use `$variableName` in `newValue` or `itemValue` to access these variables in subsequent actions.
-   Variables are local to one method execution.

**IR Action Object Structure:**
-   `"type"`: Specifies the action.
-   `"payload"`: **REQUIRED** object containing all parameters for the action.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a component property/style.
    -   `payload`: `targetId`, `propertyName` (e.g., `"value"`, `"styles.color"`), `resultVariable`.
2.  **`GET_EVENT_DATA`**: Reads data from the triggering event.
    -   `payload`: `path` (e.g., `"target.value"`, `"key"`, `"target.checked"`), `resultVariable`.
3.  **`SET_PROPERTY`**: Writes a property/style.
    -   `payload`: `targetId`, `propertyName`, `newValue` (literal or `"$varName"`).
4.  **`TOGGLE_PROPERTY`**: Toggles between two values.
    -   `payload`: `targetId`, `propertyName`, `values` (array[2]).
5.  **`ADD_ITEM`**: Adds item to list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemValue` (literal/object or `"$varName"`).
6.  **`REMOVE_ITEM`**: Removes item from list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemIndex` OR `itemValue`.
7.  **`LOG_MESSAGE`**: Logs to console.
    -   `payload`: `message` (string, can include `$varName`).
8.  **`CALL_METHOD`**: Calls another component's defined IR method.
    -   `payload`: `targetId` (ID of component to call), `methodName` (string, name of method in target's `methods`), `args` (optional array of literal values or `"$varName"` to pass as arguments - **Note:** frontend support for passing/receiving args might be limited).
    ```json
    // Example: Button click calls 'increment' method on component 'counter-comp'
    { "type": "CALL_METHOD", "payload": { "targetId": "counter-comp", "methodName": "increment" } }
    ```

# --- IR USAGE PATTERNS --- #

## IR Pattern: Handling Input Changes (Required for ALL input types)

# Component: `my-input` (text-input, textarea, select, checkbox, radio-group)
```json
// In methods for 'my-input':
"change": [
  {
    "type": "GET_EVENT_DATA",
    "payload": {
      "path": "target.value", // Or "target.checked"
      "resultVariable": "newValueFromEvent"
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "my-input", 
      "propertyName": "value", // Or "checked"
      "newValue": "$newValueFromEvent"
    }
  }
]
```

## IR Pattern: Button Click -> Update List

# Components: `item-input`, `add-button`, `item-list`
```json
// In methods for 'add-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" } },
  { "type": "ADD_ITEM", "payload": { "targetId": "item-list", "itemValue": "$newItemText" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Button Click -> Toggle Style/Class

# Components: `toggle-button`, `target-element`
```json
// Toggle Style:
// In methods for 'toggle-button':
"click": [
  { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
]

// Toggle Class (Example assumes a CSS class "active" exists):
// In methods for 'toggle-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "resultVariable": "currentClass" } },
  // NOTE: Requires IF logic or helper - simplified here. Use TOGGLE_PROPERTY if possible.
  // Conceptual - actual implementation might differ based on exact frontend capabilities
  { "type": "SET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "newValue": /* Logic to add/remove 'active' based on $currentClass */ } }
]
```

## IR Pattern: List Item Interaction (Deletion)

# Component: `my-list` (List with itemTemplate)
```json
// Within the `itemTemplate` definition:
{
  "id": "delete-btn-{{itemId}}", 
  "type": "button", "properties": { "content": "X" },
  "methods": {
    "click": [
      { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "{itemId}" } }
    ]
  }
}
```

## IR Pattern: Form Submission (Log Values)

# Components: `name-input`, `email-input`, `submit-button` (or form with submit method)
```json
// In methods for 'submit-button' OR 'form.submit':
"click": [ // Or "submit"
  { "type": "GET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "resultVariable": "nameVal" } },
  { "type": "GET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "resultVariable": "emailVal" } },
  { "type": "LOG_MESSAGE", "payload": { "message": "Form Submitted: Name=$nameVal, Email=$emailVal" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "newValue": "" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Trigger Action on Enter Key

# Component: `my-input` (text-input)
```json
// In methods for 'my-input':
"keyPress": [
  { "type": "GET_EVENT_DATA", "payload": { "path": "key", "resultVariable": "pressedKey" } },
  // NOTE: Requires IF logic not currently specified in standard IR actions.
  // This pattern shows intent; actual implementation would depend on conditional support.
  // Conceptual: IF $pressedKey === 'Enter' THEN...
  { "type": "LOG_MESSAGE", "payload": { "message": "Enter key pressed! (Actual action requires IF)" } }
]
```

## IR Pattern: Calling Another Component's Method

# Components: `trigger-button`, `counter-display` (assume counter-display has an `increment` method)
```json
// In methods for 'trigger-button':
"click": [
  { "type": "LOG_MESSAGE", "payload": { "message": "Calling counter increment..." } },
  { 
    "type": "CALL_METHOD", 
    "payload": { 
      "targetId": "counter-display", 
      "methodName": "increment" 
      // "args": ["$someValue"] // Optional arguments
    } 
  }
]
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components. Infer the necessary interactions from the user request and component relationships. Use the patterns above as guides. The application MUST be functional based on your generated IR.

# IMPORTANT ANTI-PATTERNS TO AVOID:

# 1. Incorrect Input onChange Handler:
  - **WRONG:** Using `GET_PROPERTY` to read the input's own value within its `onChange`.
    ```json
    // --- INCORRECT --- DO NOT DO THIS:
    "onChange": [
      { "type": "GET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "resultVariable": "val" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$val" } }
    ]
    ```
  - **CORRECT:** Using `GET_EVENT_DATA` to read `event.target.value` (or `event.target.checked` etc.).
    ```json
    // --- CORRECT --- USE THIS PATTERN:
    "onChange": [
      { "type": "GET_EVENT_DATA", "payload": { "path": "target.value", "resultVariable": "currentValue" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$currentValue" } }
    ]
    ```

# 2. Modifying Own Methods:
   - Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method.
   - Use conditional logic *within* the *existing* IR sequence (like `TOGGLE_PROPERTY`).

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex", // Or other layout types if applicable
    "direction": "vertical" // Or horizontal
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // FROM THE AVAILABLE LIST
      "properties": { /* Component-specific properties based on documentation above */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { 
        // CRITICAL: Define methods with IR actions here for ALL interactive components!
        "click": [ /* Example for a button */
          { "type": "GET_PROPERTY", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
          // ... more actions ...
        ],
        "change": [ /* Example for an input */
          { "type": "GET_EVENT_DATA", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
        ]
        // ... other methods as needed (submit, keyPress, etc.) ...
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "itemTemplate": { /* ONLY for 'list' components needing structured items */ },
      "children": [ /* Optional: Nested component objects for containers/layout */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: **MANDATORY** for interactive elements. Use the IR actions defined above. Implement the core application logic here.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods connecting components.

**FINAL REQUIREMENT: ALL interactive elements (buttons, inputs, checkboxes, selects, interactive list items, etc.) MUST have appropriate methods (`click`, `change`, etc.) defined using the IR actions to ensure functionality.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!
--- End of Prompt ---

--- Prompt at 2025-04-19 18:50:29.269102 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior. The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs deeply.
- Select and arrange appropriate components from the list below.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together logically to provide the requested functionality.
- **CRITICAL: You MUST infer the intended relationships and interactions between components.** For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input). A functional application requires defining `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.). Analyze the request and generate all necessary IR action sequences.
- **COMPLETENESS:** When asked for common application types (e.g., todo list, counter, form, calculator), ensure *all standard features* are implemented using the available components and IR methods. (e.g., a todo list needs add, display, *and* delete functionality).

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Usage Notes` for required methods and properties.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. Can be styled as needed.
    -   Properties: `className` (string, for applying CSS classes).
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `border`, `backgroundColor`, etc. for layout and appearance.
    -   Usage Notes: The primary tool for organizing the UI structure. Can have its `className` updated via `SET_PROPERTY` for dynamic styling.
-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid).
    -   Properties: `container` (boolean), `item` (boolean), `spacing` (number), `direction` ('row'|'column'), `wrap` ('wrap'|'nowrap'), `className` (string).
    -   Styles: Can be styled like a container.
    -   Usage Notes: Useful for creating structured layouts with consistent spacing.
-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow.
    -   Properties: `elevation` (number), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Usage Notes: Good for grouping related content visually.
-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure.
    -   Properties: `className` (string).
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties: `content` (string), `variant` (string, optional), `className` (string).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`.
    -   Usage Notes: Use `variant` for semantic meaning. `content` is updated via `SET_PROPERTY`. `className` allows dynamic style changes.
-   **`image`**
    -   Purpose: Displays an image.
    -   Properties: `src` (string URL), `alt` (string), `className` (string).
    -   Styles: `width`, `height`, `objectFit`, `borderRadius`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties: `content` (string), `variant` (string, optional), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence.
-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string, optional), `type` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern. Can also use `keyPress`/`keyDown`/`keyUp` methods.
-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string), `rows` (number), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` similar to `text-input`.
-   **`checkbox`**
    -   Purpose: A checkbox input.
    -   Properties: `label` (string), `checked` (boolean), `disabled` (boolean), `className` (string).
    -   Styles: `margin`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.checked`) -> `SET_PROPERTY`(`propertyName`: `checked`) pattern.
-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one can be selected.
    -   Properties: `options` (array of {label: string, value: string}), `value` (string), `name` (string), `disabled` (boolean), `className` (string).
    -   Styles: Can style the container.
    -   Usage Notes: Requires `methods.change` to update the selected `value`.
-   **`select`**
    -   Purpose: A dropdown selection input.
    -   Properties: `label` (string), `options` (array of {value: string, label: string}), `value` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern.
-   **`form`**
    -   Purpose: Semantic grouping for input elements. Can potentially handle submissions.
    -   Properties: `submitButtonText` (string, optional).
    -   Usage Notes: Can have a `methods.submit` handler. Alternatively, submission logic is often placed in a button's `click` method within the form.

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties: `items` (array).
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: Items managed via `ADD_ITEM`/`REMOVE_ITEM`. For structured items, **MUST** define `itemTemplate` object property. See IR patterns.
-   **`datagrid`**
    -   Purpose: Displays data in a table.
    -   Properties: `data` (array), `columns` (array), `pagination` (boolean), `pageSize` (number), `sortable` (boolean), `filterable` (boolean).
    -   Styles: `height`, `width`.
-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data.
    -   Properties: Vary: `data`, `keys`, `title`, etc.
    -   Styles: `height`, `width`.

### Media

-   **`video`**
    -   Purpose: Displays video, optionally from camera.
    -   Properties: `src`, `useCamera`, `facingMode`, `autoPlay`, `controls`, `muted`.
    -   Styles: `width`, `height`, `objectFit`.
-   **`canvas`**
    -   Purpose: Drawing surface.
    -   Properties: `width`, `height`.

### Utility

-   **`script`**
    -   Purpose: Embeds custom JS (Discouraged! Prefer IR).
    -   Properties: `content` or `src`.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`, `"keyPress"`, `"submit"`) maps to an **array `[]` of action objects** that execute sequentially.

**Supported Events:** You can define methods for standard DOM events like `click`, `change`, `submit`, `mouseEnter`, `mouseLeave`, `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

**Variables:**
-   `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables (`resultVariable`).
-   Use `$variableName` in `newValue` or `itemValue` to access these variables in subsequent actions.
-   Variables are local to one method execution.

**IR Action Object Structure:**
-   `"type"`: Specifies the action.
-   `"payload"`: **REQUIRED** object containing all parameters for the action.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a component property/style.
    -   `payload`: `targetId`, `propertyName` (e.g., `"value"`, `"styles.color"`), `resultVariable`.
2.  **`GET_EVENT_DATA`**: Reads data from the triggering event.
    -   `payload`: `path` (e.g., `"target.value"`, `"key"`, `"target.checked"`), `resultVariable`.
3.  **`SET_PROPERTY`**: Writes a property/style.
    -   `payload`: `targetId`, `propertyName`, `newValue` (literal or `"$varName"`).
4.  **`TOGGLE_PROPERTY`**: Toggles between two values.
    -   `payload`: `targetId`, `propertyName`, `values` (array[2]).
5.  **`ADD_ITEM`**: Adds item to list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemValue` (literal/object or `"$varName"`).
6.  **`REMOVE_ITEM`**: Removes item from list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemIndex` OR `itemValue`.
7.  **`LOG_MESSAGE`**: Logs to console.
    -   `payload`: `message` (string, can include `$varName`).
8.  **`CALL_METHOD`**: Calls another component's defined IR method.
    -   `payload`: `targetId` (ID of component to call), `methodName` (string, name of method in target's `methods`), `args` (optional array of literal values or `"$varName"` to pass as arguments - **Note:** frontend support for passing/receiving args might be limited).
    ```json
    // Example: Button click calls 'increment' method on component 'counter-comp'
    { "type": "CALL_METHOD", "payload": { "targetId": "counter-comp", "methodName": "increment" } }
    ```

# --- IR USAGE PATTERNS --- #

## IR Pattern: Handling Input Changes (Required for ALL input types)

# Component: `my-input` (text-input, textarea, select, checkbox, radio-group)
```json
// In methods for 'my-input':
"change": [
  {
    "type": "GET_EVENT_DATA",
    "payload": {
      "path": "target.value", // Or "target.checked"
      "resultVariable": "newValueFromEvent"
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "my-input", 
      "propertyName": "value", // Or "checked"
      "newValue": "$newValueFromEvent"
    }
  }
]
```

## IR Pattern: Button Click -> Update List

# Components: `item-input`, `add-button`, `item-list`
```json
// In methods for 'add-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" } },
  { "type": "ADD_ITEM", "payload": { "targetId": "item-list", "itemValue": "$newItemText" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Button Click -> Toggle Style/Class

# Components: `toggle-button`, `target-element`
```json
// Toggle Style:
// In methods for 'toggle-button':
"click": [
  { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
]

// Toggle Class (Example assumes a CSS class "active" exists):
// In methods for 'toggle-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "resultVariable": "currentClass" } },
  // NOTE: Requires IF logic or helper - simplified here. Use TOGGLE_PROPERTY if possible.
  // Conceptual - actual implementation might differ based on exact frontend capabilities
  { "type": "SET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "newValue": /* Logic to add/remove 'active' based on $currentClass */ } }
]
```

## IR Pattern: List Item Interaction (Deletion)

# Component: `my-list` (List with itemTemplate)
```json
// Within the `itemTemplate` definition:
{
  "id": "delete-btn-{{itemId}}", 
  "type": "button", "properties": { "content": "X" },
  "methods": {
    "click": [
      { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "{itemId}" } }
    ]
  }
}
```

## IR Pattern: Form Submission (Log Values)

# Components: `name-input`, `email-input`, `submit-button` (or form with submit method)
```json
// In methods for 'submit-button' OR 'form.submit':
"click": [ // Or "submit"
  { "type": "GET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "resultVariable": "nameVal" } },
  { "type": "GET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "resultVariable": "emailVal" } },
  { "type": "LOG_MESSAGE", "payload": { "message": "Form Submitted: Name=$nameVal, Email=$emailVal" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "newValue": "" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Trigger Action on Enter Key

# Component: `my-input` (text-input)
```json
// In methods for 'my-input':
"keyPress": [
  { "type": "GET_EVENT_DATA", "payload": { "path": "key", "resultVariable": "pressedKey" } },
  // NOTE: Requires IF logic not currently specified in standard IR actions.
  // This pattern shows intent; actual implementation would depend on conditional support.
  // Conceptual: IF $pressedKey === 'Enter' THEN...
  { "type": "LOG_MESSAGE", "payload": { "message": "Enter key pressed! (Actual action requires IF)" } }
]
```

## IR Pattern: Calling Another Component's Method

# Components: `trigger-button`, `counter-display` (assume counter-display has an `increment` method)
```json
// In methods for 'trigger-button':
"click": [
  { "type": "LOG_MESSAGE", "payload": { "message": "Calling counter increment..." } },
  { 
    "type": "CALL_METHOD", 
    "payload": { 
      "targetId": "counter-display", 
      "methodName": "increment" 
      // "args": ["$someValue"] // Optional arguments
    } 
  }
]
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components. Infer the necessary interactions from the user request and component relationships. Use the patterns above as guides. The application MUST be functional based on your generated IR.

# IMPORTANT ANTI-PATTERNS TO AVOID:

# 1. Incorrect Input onChange Handler:
  - **WRONG:** Using `GET_PROPERTY` to read the input's own value within its `onChange`.
    ```json
    // --- INCORRECT --- DO NOT DO THIS:
    "onChange": [
      { "type": "GET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "resultVariable": "val" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$val" } }
    ]
    ```
  - **CORRECT:** Using `GET_EVENT_DATA` to read `event.target.value` (or `event.target.checked` etc.).
    ```json
    // --- CORRECT --- USE THIS PATTERN:
    "onChange": [
      { "type": "GET_EVENT_DATA", "payload": { "path": "target.value", "resultVariable": "currentValue" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$currentValue" } }
    ]
    ```

# 2. Modifying Own Methods:
   - Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method.
   - Use conditional logic *within* the *existing* IR sequence (like `TOGGLE_PROPERTY`).

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex", // Or other layout types if applicable
    "direction": "vertical" // Or horizontal
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // FROM THE AVAILABLE LIST
      "properties": { /* Component-specific properties based on documentation above */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { 
        // CRITICAL: Define methods with IR actions here for ALL interactive components!
        "click": [ /* Example for a button */
          { "type": "GET_PROPERTY", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
          // ... more actions ...
        ],
        "change": [ /* Example for an input */
          { "type": "GET_EVENT_DATA", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
        ]
        // ... other methods as needed (submit, keyPress, etc.) ...
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "itemTemplate": { /* ONLY for 'list' components needing structured items */ },
      "children": [ /* Optional: Nested component objects for containers/layout */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: **MANDATORY** for interactive elements. Use the IR actions defined above. Implement the core application logic here.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods connecting components.

**FINAL REQUIREMENT: ALL interactive elements (buttons, inputs, checkboxes, selects, interactive list items, etc.) MUST have appropriate methods (`click`, `change`, etc.) defined using the IR actions to ensure functionality.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!
--- End of Prompt ---

--- Prompt at 2025-04-19 18:58:23.375613 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior. The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs deeply.
- Select and arrange appropriate components from the list below.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together logically to provide the requested functionality.
- **CRITICAL: You MUST infer the intended relationships and interactions between components.** For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input). A functional application requires defining `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.). Analyze the request and generate all necessary IR action sequences.
- **COMPLETENESS:** When asked for common application types (e.g., todo list, counter, form, calculator), ensure *all standard features* are implemented using the available components and IR methods. (e.g., a todo list needs add, display, *and* delete functionality).

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Usage Notes` for required methods and properties.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. Can be styled as needed.
    -   Properties: `className` (string, for applying CSS classes).
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `border`, `backgroundColor`, etc. for layout and appearance.
    -   Usage Notes: The primary tool for organizing the UI structure. Can have its `className` updated via `SET_PROPERTY` for dynamic styling.
-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid).
    -   Properties: `container` (boolean), `item` (boolean), `spacing` (number), `direction` ('row'|'column'), `wrap` ('wrap'|'nowrap'), `className` (string).
    -   Styles: Can be styled like a container.
    -   Usage Notes: Useful for creating structured layouts with consistent spacing.
-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow.
    -   Properties: `elevation` (number), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Usage Notes: Good for grouping related content visually.
-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure.
    -   Properties: `className` (string).
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties: `content` (string), `variant` (string, optional), `className` (string).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`.
    -   Usage Notes: Use `variant` for semantic meaning. `content` is updated via `SET_PROPERTY`. `className` allows dynamic style changes.
-   **`image`**
    -   Purpose: Displays an image.
    -   Properties: `src` (string URL), `alt` (string), `className` (string).
    -   Styles: `width`, `height`, `objectFit`, `borderRadius`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties: `content` (string), `variant` (string, optional), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence.
-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string, optional), `type` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern. Can also use `keyPress`/`keyDown`/`keyUp` methods.
-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string), `rows` (number), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` similar to `text-input`.
-   **`checkbox`**
    -   Purpose: A checkbox input.
    -   Properties: `label` (string), `checked` (boolean), `disabled` (boolean), `className` (string).
    -   Styles: `margin`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.checked`) -> `SET_PROPERTY`(`propertyName`: `checked`) pattern.
-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one can be selected.
    -   Properties: `options` (array of {label: string, value: string}), `value` (string), `name` (string), `disabled` (boolean), `className` (string).
    -   Styles: Can style the container.
    -   Usage Notes: Requires `methods.change` to update the selected `value`.
-   **`select`**
    -   Purpose: A dropdown selection input.
    -   Properties: `label` (string), `options` (array of {value: string, label: string}), `value` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern.
-   **`form`**
    -   Purpose: Semantic grouping for input elements. Can potentially handle submissions.
    -   Properties: `submitButtonText` (string, optional).
    -   Usage Notes: Can have a `methods.submit` handler. Alternatively, submission logic is often placed in a button's `click` method within the form.

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties: `items` (array).
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: Items managed via `ADD_ITEM`/`REMOVE_ITEM`. For structured items, **MUST** define `itemTemplate` object property. See IR patterns.
-   **`datagrid`**
    -   Purpose: Displays data in a table.
    -   Properties: `data` (array), `columns` (array), `pagination` (boolean), `pageSize` (number), `sortable` (boolean), `filterable` (boolean).
    -   Styles: `height`, `width`.
-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data.
    -   Properties: Vary: `data`, `keys`, `title`, etc.
    -   Styles: `height`, `width`.

### Media

-   **`video`**
    -   Purpose: Displays video, optionally from camera.
    -   Properties: `src`, `useCamera`, `facingMode`, `autoPlay`, `controls`, `muted`.
    -   Styles: `width`, `height`, `objectFit`.
-   **`canvas`**
    -   Purpose: Drawing surface.
    -   Properties: `width`, `height`.

### Utility

-   **`script`**
    -   Purpose: Embeds custom JS (Discouraged! Prefer IR).
    -   Properties: `content` or `src`.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`, `"keyPress"`, `"submit"`) maps to an **array `[]` of action objects** that execute sequentially.

**Supported Events:** You can define methods for standard DOM events like `click`, `change`, `submit`, `mouseEnter`, `mouseLeave`, `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

**Variables:**
-   `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables (`resultVariable`).
-   Use `$variableName` in `newValue` or `itemValue` to access these variables in subsequent actions.
-   Variables are local to one method execution.

**IR Action Object Structure:**
-   `"type"`: Specifies the action.
-   `"payload"`: **REQUIRED** object containing all parameters for the action.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a component property/style.
    -   `payload`: `targetId`, `propertyName` (e.g., `"value"`, `"styles.color"`), `resultVariable`.
2.  **`GET_EVENT_DATA`**: Reads data from the triggering event.
    -   `payload`: `path` (e.g., `"target.value"`, `"key"`, `"target.checked"`), `resultVariable`.
3.  **`SET_PROPERTY`**: Writes a property/style.
    -   `payload`: `targetId`, `propertyName`, `newValue` (literal or `"$varName"`).
4.  **`TOGGLE_PROPERTY`**: Toggles between two values.
    -   `payload`: `targetId`, `propertyName`, `values` (array[2]).
5.  **`ADD_ITEM`**: Adds item to list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemValue` (literal/object or `"$varName"`).
6.  **`REMOVE_ITEM`**: Removes item from list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemIndex` OR `itemValue`.
7.  **`LOG_MESSAGE`**: Logs to console.
    -   `payload`: `message` (string, can include `$varName`).
8.  **`CALL_METHOD`**: Calls another component's defined IR method.
    -   `payload`: `targetId` (ID of component to call), `methodName` (string, name of method in target's `methods`), `args` (optional array of literal values or `"$varName"` to pass as arguments - **Note:** frontend support for passing/receiving args might be limited).
    ```json
    // Example: Button click calls 'increment' method on component 'counter-comp'
    { "type": "CALL_METHOD", "payload": { "targetId": "counter-comp", "methodName": "increment" } }
    ```

# --- IR USAGE PATTERNS --- #

## IR Pattern: Handling Input Changes (Required for ALL input types)

# Component: `my-input` (text-input, textarea, select, checkbox, radio-group)
```json
// In methods for 'my-input':
"change": [
  {
    "type": "GET_EVENT_DATA",
    "payload": {
      "path": "target.value", // Or "target.checked"
      "resultVariable": "newValueFromEvent"
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "my-input", 
      "propertyName": "value", // Or "checked"
      "newValue": "$newValueFromEvent"
    }
  }
]
```

## IR Pattern: Button Click -> Update List

# Components: `item-input`, `add-button`, `item-list`
```json
// In methods for 'add-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" } },
  { "type": "ADD_ITEM", "payload": { "targetId": "item-list", "itemValue": "$newItemText" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Button Click -> Toggle Style/Class

# Components: `toggle-button`, `target-element`
```json
// Toggle Style:
// In methods for 'toggle-button':
"click": [
  { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
]

// Toggle Class (Example assumes a CSS class "active" exists):
// In methods for 'toggle-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "resultVariable": "currentClass" } },
  // NOTE: Requires IF logic or helper - simplified here. Use TOGGLE_PROPERTY if possible.
  // Conceptual - actual implementation might differ based on exact frontend capabilities
  { "type": "SET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "newValue": /* Logic to add/remove 'active' based on $currentClass */ } }
]
```

## IR Pattern: List Item Interaction (Deletion)

# Component: `my-list` (List with itemTemplate)
```json
// Within the `itemTemplate` definition:
{
  "id": "delete-btn-{{itemId}}", 
  "type": "button", "properties": { "content": "X" },
  "methods": {
    "click": [
      { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "{itemId}" } }
    ]
  }
}
```

## IR Pattern: Form Submission (Log Values)

# Components: `name-input`, `email-input`, `submit-button` (or form with submit method)
```json
// In methods for 'submit-button' OR 'form.submit':
"click": [ // Or "submit"
  { "type": "GET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "resultVariable": "nameVal" } },
  { "type": "GET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "resultVariable": "emailVal" } },
  { "type": "LOG_MESSAGE", "payload": { "message": "Form Submitted: Name=$nameVal, Email=$emailVal" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "newValue": "" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Trigger Action on Enter Key

# Component: `my-input` (text-input)
```json
// In methods for 'my-input':
"keyPress": [
  { "type": "GET_EVENT_DATA", "payload": { "path": "key", "resultVariable": "pressedKey" } },
  // NOTE: Requires IF logic not currently specified in standard IR actions.
  // This pattern shows intent; actual implementation would depend on conditional support.
  // Conceptual: IF $pressedKey === 'Enter' THEN...
  { "type": "LOG_MESSAGE", "payload": { "message": "Enter key pressed! (Actual action requires IF)" } }
]
```

## IR Pattern: Calling Another Component's Method

# Components: `trigger-button`, `counter-display` (assume counter-display has an `increment` method)
```json
// In methods for 'trigger-button':
"click": [
  { "type": "LOG_MESSAGE", "payload": { "message": "Calling counter increment..." } },
  { 
    "type": "CALL_METHOD", 
    "payload": { 
      "targetId": "counter-display", 
      "methodName": "increment" 
      // "args": ["$someValue"] // Optional arguments
    } 
  }
]
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components. Infer the necessary interactions from the user request and component relationships. Use the patterns above as guides. The application MUST be functional based on your generated IR.

# IMPORTANT ANTI-PATTERNS TO AVOID:

# 1. Incorrect Input onChange Handler:
  - **WRONG:** Using `GET_PROPERTY` to read the input's own value within its `onChange`.
    ```json
    // --- INCORRECT --- DO NOT DO THIS:
    "onChange": [
      { "type": "GET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "resultVariable": "val" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$val" } }
    ]
    ```
  - **CORRECT:** Using `GET_EVENT_DATA` to read `event.target.value` (or `event.target.checked` etc.).
    ```json
    // --- CORRECT --- USE THIS PATTERN:
    "onChange": [
      { "type": "GET_EVENT_DATA", "payload": { "path": "target.value", "resultVariable": "currentValue" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$currentValue" } }
    ]
    ```

# 2. Modifying Own Methods:
   - Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method.
   - Use conditional logic *within* the *existing* IR sequence (like `TOGGLE_PROPERTY`).

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex", // Or other layout types if applicable
    "direction": "vertical" // Or horizontal
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // FROM THE AVAILABLE LIST
      "properties": { /* Component-specific properties based on documentation above */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { 
        // CRITICAL: Define methods with IR actions here for ALL interactive components!
        "click": [ /* Example for a button */
          { "type": "GET_PROPERTY", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
          // ... more actions ...
        ],
        "change": [ /* Example for an input */
          { "type": "GET_EVENT_DATA", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
        ]
        // ... other methods as needed (submit, keyPress, etc.) ...
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "itemTemplate": { /* ONLY for 'list' components needing structured items */ },
      "children": [ /* Optional: Nested component objects for containers/layout */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: **MANDATORY** for interactive elements. Use the IR actions defined above. Implement the core application logic here.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods connecting components.

**FINAL REQUIREMENT: ALL interactive elements (buttons, inputs, checkboxes, selects, interactive list items, etc.) MUST have appropriate methods (`click`, `change`, etc.) defined using the IR actions to ensure functionality.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!
--- End of Prompt ---

--- Prompt at 2025-04-19 18:58:51.404124 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a calculator
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior. The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs deeply.
- Select and arrange appropriate components from the list below.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together logically to provide the requested functionality.
- **CRITICAL: You MUST infer the intended relationships and interactions between components.** For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input). A functional application requires defining `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.). Analyze the request and generate all necessary IR action sequences.
- **COMPLETENESS:** When asked for common application types (e.g., todo list, counter, form, calculator), ensure *all standard features* are implemented using the available components and IR methods. (e.g., a todo list needs add, display, *and* delete functionality).

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Usage Notes` for required methods and properties.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. Can be styled as needed.
    -   Properties: `className` (string, for applying CSS classes).
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `border`, `backgroundColor`, etc. for layout and appearance.
    -   Usage Notes: The primary tool for organizing the UI structure. Can have its `className` updated via `SET_PROPERTY` for dynamic styling.
-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid).
    -   Properties: `container` (boolean), `item` (boolean), `spacing` (number), `direction` ('row'|'column'), `wrap` ('wrap'|'nowrap'), `className` (string).
    -   Styles: Can be styled like a container.
    -   Usage Notes: Useful for creating structured layouts with consistent spacing.
-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow.
    -   Properties: `elevation` (number), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Usage Notes: Good for grouping related content visually.
-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure.
    -   Properties: `className` (string).
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties: `content` (string), `variant` (string, optional), `className` (string).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`.
    -   Usage Notes: Use `variant` for semantic meaning. `content` is updated via `SET_PROPERTY`. `className` allows dynamic style changes.
-   **`image`**
    -   Purpose: Displays an image.
    -   Properties: `src` (string URL), `alt` (string), `className` (string).
    -   Styles: `width`, `height`, `objectFit`, `borderRadius`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties: `content` (string), `variant` (string, optional), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence.
-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string, optional), `type` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern. Can also use `keyPress`/`keyDown`/`keyUp` methods.
-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string), `rows` (number), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` similar to `text-input`.
-   **`checkbox`**
    -   Purpose: A checkbox input.
    -   Properties: `label` (string), `checked` (boolean), `disabled` (boolean), `className` (string).
    -   Styles: `margin`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.checked`) -> `SET_PROPERTY`(`propertyName`: `checked`) pattern.
-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one can be selected.
    -   Properties: `options` (array of {label: string, value: string}), `value` (string), `name` (string), `disabled` (boolean), `className` (string).
    -   Styles: Can style the container.
    -   Usage Notes: Requires `methods.change` to update the selected `value`.
-   **`select`**
    -   Purpose: A dropdown selection input.
    -   Properties: `label` (string), `options` (array of {value: string, label: string}), `value` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern.
-   **`form`**
    -   Purpose: Semantic grouping for input elements. Can potentially handle submissions.
    -   Properties: `submitButtonText` (string, optional).
    -   Usage Notes: Can have a `methods.submit` handler. Alternatively, submission logic is often placed in a button's `click` method within the form.

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties: `items` (array).
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: Items managed via `ADD_ITEM`/`REMOVE_ITEM`. For structured items, **MUST** define `itemTemplate` object property. See IR patterns.
-   **`datagrid`**
    -   Purpose: Displays data in a table.
    -   Properties: `data` (array), `columns` (array), `pagination` (boolean), `pageSize` (number), `sortable` (boolean), `filterable` (boolean).
    -   Styles: `height`, `width`.
-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data.
    -   Properties: Vary: `data`, `keys`, `title`, etc.
    -   Styles: `height`, `width`.

### Media

-   **`video`**
    -   Purpose: Displays video, optionally from camera.
    -   Properties: `src`, `useCamera`, `facingMode`, `autoPlay`, `controls`, `muted`.
    -   Styles: `width`, `height`, `objectFit`.
-   **`canvas`**
    -   Purpose: Drawing surface.
    -   Properties: `width`, `height`.

### Utility

-   **`script`**
    -   Purpose: Embeds custom JS (Discouraged! Prefer IR).
    -   Properties: `content` or `src`.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`, `"keyPress"`, `"submit"`) maps to an **array `[]` of action objects** that execute sequentially.

**Supported Events:** You can define methods for standard DOM events like `click`, `change`, `submit`, `mouseEnter`, `mouseLeave`, `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

**Variables:**
-   `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables (`resultVariable`).
-   Use `$variableName` in `newValue` or `itemValue` to access these variables in subsequent actions.
-   Variables are local to one method execution.

**IR Action Object Structure:**
-   `"type"`: Specifies the action.
-   `"payload"`: **REQUIRED** object containing all parameters for the action.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a component property/style.
    -   `payload`: `targetId`, `propertyName` (e.g., `"value"`, `"styles.color"`), `resultVariable`.
2.  **`GET_EVENT_DATA`**: Reads data from the triggering event.
    -   `payload`: `path` (e.g., `"target.value"`, `"key"`, `"target.checked"`), `resultVariable`.
3.  **`SET_PROPERTY`**: Writes a property/style.
    -   `payload`: `targetId`, `propertyName`, `newValue` (literal or `"$varName"`).
4.  **`TOGGLE_PROPERTY`**: Toggles between two values.
    -   `payload`: `targetId`, `propertyName`, `values` (array[2]).
5.  **`ADD_ITEM`**: Adds item to list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemValue` (literal/object or `"$varName"`).
6.  **`REMOVE_ITEM`**: Removes item from list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemIndex` OR `itemValue`.
7.  **`LOG_MESSAGE`**: Logs to console.
    -   `payload`: `message` (string, can include `$varName`).
8.  **`CALL_METHOD`**: Calls another component's defined IR method.
    -   `payload`: `targetId` (ID of component to call), `methodName` (string, name of method in target's `methods`), `args` (optional array of literal values or `"$varName"` to pass as arguments - **Note:** frontend support for passing/receiving args might be limited).
    ```json
    // Example: Button click calls 'increment' method on component 'counter-comp'
    { "type": "CALL_METHOD", "payload": { "targetId": "counter-comp", "methodName": "increment" } }
    ```

# --- IR USAGE PATTERNS --- #

## IR Pattern: Handling Input Changes (Required for ALL input types)

# Component: `my-input` (text-input, textarea, select, checkbox, radio-group)
```json
// In methods for 'my-input':
"change": [
  {
    "type": "GET_EVENT_DATA",
    "payload": {
      "path": "target.value", // Or "target.checked"
      "resultVariable": "newValueFromEvent"
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "my-input", 
      "propertyName": "value", // Or "checked"
      "newValue": "$newValueFromEvent"
    }
  }
]
```

## IR Pattern: Button Click -> Update List

# Components: `item-input`, `add-button`, `item-list`
```json
// In methods for 'add-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" } },
  { "type": "ADD_ITEM", "payload": { "targetId": "item-list", "itemValue": "$newItemText" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Button Click -> Toggle Style/Class

# Components: `toggle-button`, `target-element`
```json
// Toggle Style:
// In methods for 'toggle-button':
"click": [
  { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
]

// Toggle Class (Example assumes a CSS class "active" exists):
// In methods for 'toggle-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "resultVariable": "currentClass" } },
  // NOTE: Requires IF logic or helper - simplified here. Use TOGGLE_PROPERTY if possible.
  // Conceptual - actual implementation might differ based on exact frontend capabilities
  { "type": "SET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "newValue": /* Logic to add/remove 'active' based on $currentClass */ } }
]
```

## IR Pattern: List Item Interaction (Deletion)

# Component: `my-list` (List with itemTemplate)
```json
// Within the `itemTemplate` definition:
{
  "id": "delete-btn-{{itemId}}", 
  "type": "button", "properties": { "content": "X" },
  "methods": {
    "click": [
      { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "{itemId}" } }
    ]
  }
}
```

## IR Pattern: Form Submission (Log Values)

# Components: `name-input`, `email-input`, `submit-button` (or form with submit method)
```json
// In methods for 'submit-button' OR 'form.submit':
"click": [ // Or "submit"
  { "type": "GET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "resultVariable": "nameVal" } },
  { "type": "GET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "resultVariable": "emailVal" } },
  { "type": "LOG_MESSAGE", "payload": { "message": "Form Submitted: Name=$nameVal, Email=$emailVal" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "newValue": "" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Trigger Action on Enter Key

# Component: `my-input` (text-input)
```json
// In methods for 'my-input':
"keyPress": [
  { "type": "GET_EVENT_DATA", "payload": { "path": "key", "resultVariable": "pressedKey" } },
  // NOTE: Requires IF logic not currently specified in standard IR actions.
  // This pattern shows intent; actual implementation would depend on conditional support.
  // Conceptual: IF $pressedKey === 'Enter' THEN...
  { "type": "LOG_MESSAGE", "payload": { "message": "Enter key pressed! (Actual action requires IF)" } }
]
```

## IR Pattern: Calling Another Component's Method

# Components: `trigger-button`, `counter-display` (assume counter-display has an `increment` method)
```json
// In methods for 'trigger-button':
"click": [
  { "type": "LOG_MESSAGE", "payload": { "message": "Calling counter increment..." } },
  { 
    "type": "CALL_METHOD", 
    "payload": { 
      "targetId": "counter-display", 
      "methodName": "increment" 
      // "args": ["$someValue"] // Optional arguments
    } 
  }
]
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components. Infer the necessary interactions from the user request and component relationships. Use the patterns above as guides. The application MUST be functional based on your generated IR.

# IMPORTANT ANTI-PATTERNS TO AVOID:

# 1. Incorrect Input onChange Handler:
  - **WRONG:** Using `GET_PROPERTY` to read the input's own value within its `onChange`.
    ```json
    // --- INCORRECT --- DO NOT DO THIS:
    "onChange": [
      { "type": "GET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "resultVariable": "val" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$val" } }
    ]
    ```
  - **CORRECT:** Using `GET_EVENT_DATA` to read `event.target.value` (or `event.target.checked` etc.).
    ```json
    // --- CORRECT --- USE THIS PATTERN:
    "onChange": [
      { "type": "GET_EVENT_DATA", "payload": { "path": "target.value", "resultVariable": "currentValue" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$currentValue" } }
    ]
    ```

# 2. Modifying Own Methods:
   - Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method.
   - Use conditional logic *within* the *existing* IR sequence (like `TOGGLE_PROPERTY`).

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex", // Or other layout types if applicable
    "direction": "vertical" // Or horizontal
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // FROM THE AVAILABLE LIST
      "properties": { /* Component-specific properties based on documentation above */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { 
        // CRITICAL: Define methods with IR actions here for ALL interactive components!
        "click": [ /* Example for a button */
          { "type": "GET_PROPERTY", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
          // ... more actions ...
        ],
        "change": [ /* Example for an input */
          { "type": "GET_EVENT_DATA", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
        ]
        // ... other methods as needed (submit, keyPress, etc.) ...
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "itemTemplate": { /* ONLY for 'list' components needing structured items */ },
      "children": [ /* Optional: Nested component objects for containers/layout */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: **MANDATORY** for interactive elements. Use the IR actions defined above. Implement the core application logic here.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods connecting components.

**FINAL REQUIREMENT: ALL interactive elements (buttons, inputs, checkboxes, selects, interactive list items, etc.) MUST have appropriate methods (`click`, `change`, etc.) defined using the IR actions to ensure functionality.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!
--- End of Prompt ---

--- Prompt at 2025-04-19 19:00:01.334383 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app with a nice background
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior. The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types.

## CAMERA AND MEDIA PROCESSING REQUIREMENTS (Condensed)
- Use `<video>` component (`type: "video"`) for camera input.
- Use `<canvas>` component (`type: "canvas"`) for overlays.
- Ensure proper camera access and cleanup.

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze the user's needs deeply.
- Select and arrange appropriate components from the list below.
- Define component `properties`, `styles`, and **`methods` (using the IR described below)**.
- Ensure components work together logically to provide the requested functionality.
- **CRITICAL: You MUST infer the intended relationships and interactions between components.** For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input). A functional application requires defining `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.). Analyze the request and generate all necessary IR action sequences.
- **COMPLETENESS:** When asked for common application types (e.g., todo list, counter, form, calculator), ensure *all standard features* are implemented using the available components and IR methods. (e.g., a todo list needs add, display, *and* delete functionality).

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Usage Notes` for required methods and properties.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. Can be styled as needed.
    -   Properties: `className` (string, for applying CSS classes).
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `border`, `backgroundColor`, etc. for layout and appearance.
    -   Usage Notes: The primary tool for organizing the UI structure. Can have its `className` updated via `SET_PROPERTY` for dynamic styling.
-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid).
    -   Properties: `container` (boolean), `item` (boolean), `spacing` (number), `direction` ('row'|'column'), `wrap` ('wrap'|'nowrap'), `className` (string).
    -   Styles: Can be styled like a container.
    -   Usage Notes: Useful for creating structured layouts with consistent spacing.
-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow.
    -   Properties: `elevation` (number), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Usage Notes: Good for grouping related content visually.
-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure.
    -   Properties: `className` (string).
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties: `content` (string), `variant` (string, optional), `className` (string).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`.
    -   Usage Notes: Use `variant` for semantic meaning. `content` is updated via `SET_PROPERTY`. `className` allows dynamic style changes.
-   **`image`**
    -   Purpose: Displays an image.
    -   Properties: `src` (string URL), `alt` (string), `className` (string).
    -   Styles: `width`, `height`, `objectFit`, `borderRadius`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties: `content` (string), `variant` (string, optional), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`.
    -   Usage Notes: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence.
-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string, optional), `type` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern. Can also use `keyPress`/`keyDown`/`keyUp` methods.
-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties: `value` (string), `placeholder` (string), `label` (string), `rows` (number), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` similar to `text-input`.
-   **`checkbox`**
    -   Purpose: A checkbox input.
    -   Properties: `label` (string), `checked` (boolean), `disabled` (boolean), `className` (string).
    -   Styles: `margin`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.checked`) -> `SET_PROPERTY`(`propertyName`: `checked`) pattern.
-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one can be selected.
    -   Properties: `options` (array of {label: string, value: string}), `value` (string), `name` (string), `disabled` (boolean), `className` (string).
    -   Styles: Can style the container.
    -   Usage Notes: Requires `methods.change` to update the selected `value`.
-   **`select`**
    -   Purpose: A dropdown selection input.
    -   Properties: `label` (string), `options` (array of {value: string, label: string}), `value` (string), `disabled` (boolean), `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`.
    -   Usage Notes: **CRITICAL:** Requires `methods.change` using `GET_EVENT_DATA`(`path`: `target.value`) -> `SET_PROPERTY`(`propertyName`: `value`) pattern.
-   **`form`**
    -   Purpose: Semantic grouping for input elements. Can potentially handle submissions.
    -   Properties: `submitButtonText` (string, optional).
    -   Usage Notes: Can have a `methods.submit` handler. Alternatively, submission logic is often placed in a button's `click` method within the form.

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties: `items` (array).
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: Items managed via `ADD_ITEM`/`REMOVE_ITEM`. For structured items, **MUST** define `itemTemplate` object property. See IR patterns.
-   **`datagrid`**
    -   Purpose: Displays data in a table.
    -   Properties: `data` (array), `columns` (array), `pagination` (boolean), `pageSize` (number), `sortable` (boolean), `filterable` (boolean).
    -   Styles: `height`, `width`.
-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data.
    -   Properties: Vary: `data`, `keys`, `title`, etc.
    -   Styles: `height`, `width`.

### Media

-   **`video`**
    -   Purpose: Displays video, optionally from camera.
    -   Properties: `src`, `useCamera`, `facingMode`, `autoPlay`, `controls`, `muted`.
    -   Styles: `width`, `height`, `objectFit`.
-   **`canvas`**
    -   Purpose: Drawing surface.
    -   Properties: `width`, `height`.

### Utility

-   **`script`**
    -   Purpose: Embeds custom JS (Discouraged! Prefer IR).
    -   Properties: `content` or `src`.

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**IMPORTANT: DO NOT GENERATE JAVASCRIPT STRINGS FOR METHODS.**

Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**. Each method name (e.g., `"click"`, `"change"`, `"keyPress"`, `"submit"`) maps to an **array `[]` of action objects** that execute sequentially.

**Supported Events:** You can define methods for standard DOM events like `click`, `change`, `submit`, `mouseEnter`, `mouseLeave`, `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

**Variables:**
-   `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables (`resultVariable`).
-   Use `$variableName` in `newValue` or `itemValue` to access these variables in subsequent actions.
-   Variables are local to one method execution.

**IR Action Object Structure:**
-   `"type"`: Specifies the action.
-   `"payload"`: **REQUIRED** object containing all parameters for the action.

**Available IR Action Types:**

1.  **`GET_PROPERTY`**: Reads a component property/style.
    -   `payload`: `targetId`, `propertyName` (e.g., `"value"`, `"styles.color"`), `resultVariable`.
2.  **`GET_EVENT_DATA`**: Reads data from the triggering event.
    -   `payload`: `path` (e.g., `"target.value"`, `"key"`, `"target.checked"`), `resultVariable`.
3.  **`SET_PROPERTY`**: Writes a property/style.
    -   `payload`: `targetId`, `propertyName`, `newValue` (literal or `"$varName"`).
4.  **`TOGGLE_PROPERTY`**: Toggles between two values.
    -   `payload`: `targetId`, `propertyName`, `values` (array[2]).
5.  **`ADD_ITEM`**: Adds item to list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemValue` (literal/object or `"$varName"`).
6.  **`REMOVE_ITEM`**: Removes item from list `properties.items`.
    -   `payload`: `targetId` (list ID), `itemIndex` OR `itemValue`.
7.  **`LOG_MESSAGE`**: Logs to console.
    -   `payload`: `message` (string, can include `$varName`).
8.  **`CALL_METHOD`**: Calls another component's defined IR method.
    -   `payload`: `targetId` (ID of component to call), `methodName` (string, name of method in target's `methods`), `args` (optional array of literal values or `"$varName"` to pass as arguments - **Note:** frontend support for passing/receiving args might be limited).
    ```json
    // Example: Button click calls 'increment' method on component 'counter-comp'
    { "type": "CALL_METHOD", "payload": { "targetId": "counter-comp", "methodName": "increment" } }
    ```

# --- IR USAGE PATTERNS --- #

## IR Pattern: Handling Input Changes (Required for ALL input types)

# Component: `my-input` (text-input, textarea, select, checkbox, radio-group)
```json
// In methods for 'my-input':
"change": [
  {
    "type": "GET_EVENT_DATA",
    "payload": {
      "path": "target.value", // Or "target.checked"
      "resultVariable": "newValueFromEvent"
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "my-input", 
      "propertyName": "value", // Or "checked"
      "newValue": "$newValueFromEvent"
    }
  }
]
```

## IR Pattern: Button Click -> Update List

# Components: `item-input`, `add-button`, `item-list`
```json
// In methods for 'add-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "resultVariable": "newItemText" } },
  { "type": "ADD_ITEM", "payload": { "targetId": "item-list", "itemValue": "$newItemText" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "item-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Button Click -> Toggle Style/Class

# Components: `toggle-button`, `target-element`
```json
// Toggle Style:
// In methods for 'toggle-button':
"click": [
  { "type": "TOGGLE_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "styles.fontWeight", "values": ["normal", "bold"] } }
]

// Toggle Class (Example assumes a CSS class "active" exists):
// In methods for 'toggle-button':
"click": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "resultVariable": "currentClass" } },
  // NOTE: Requires IF logic or helper - simplified here. Use TOGGLE_PROPERTY if possible.
  // Conceptual - actual implementation might differ based on exact frontend capabilities
  { "type": "SET_PROPERTY", "payload": { "targetId": "target-element", "propertyName": "className", "newValue": /* Logic to add/remove 'active' based on $currentClass */ } }
]
```

## IR Pattern: List Item Interaction (Deletion)

# Component: `my-list` (List with itemTemplate)
```json
// Within the `itemTemplate` definition:
{
  "id": "delete-btn-{{itemId}}", 
  "type": "button", "properties": { "content": "X" },
  "methods": {
    "click": [
      { "type": "REMOVE_ITEM", "payload": { "targetId": "my-list", "itemValue": "{itemId}" } }
    ]
  }
}
```

## IR Pattern: Form Submission (Log Values)

# Components: `name-input`, `email-input`, `submit-button` (or form with submit method)
```json
// In methods for 'submit-button' OR 'form.submit':
"click": [ // Or "submit"
  { "type": "GET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "resultVariable": "nameVal" } },
  { "type": "GET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "resultVariable": "emailVal" } },
  { "type": "LOG_MESSAGE", "payload": { "message": "Form Submitted: Name=$nameVal, Email=$emailVal" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "name-input", "propertyName": "value", "newValue": "" } },
  { "type": "SET_PROPERTY", "payload": { "targetId": "email-input", "propertyName": "value", "newValue": "" } }
]
```

## IR Pattern: Trigger Action on Enter Key

# Component: `my-input` (text-input)
```json
// In methods for 'my-input':
"keyPress": [
  { "type": "GET_EVENT_DATA", "payload": { "path": "key", "resultVariable": "pressedKey" } },
  // NOTE: Requires IF logic not currently specified in standard IR actions.
  // This pattern shows intent; actual implementation would depend on conditional support.
  // Conceptual: IF $pressedKey === 'Enter' THEN...
  { "type": "LOG_MESSAGE", "payload": { "message": "Enter key pressed! (Actual action requires IF)" } }
]
```

## IR Pattern: Calling Another Component's Method

# Components: `trigger-button`, `counter-display` (assume counter-display has an `increment` method)
```json
// In methods for 'trigger-button':
"click": [
  { "type": "LOG_MESSAGE", "payload": { "message": "Calling counter increment..." } },
  { 
    "type": "CALL_METHOD", 
    "payload": { 
      "targetId": "counter-display", 
      "methodName": "increment" 
      // "args": ["$someValue"] // Optional arguments
    } 
  }
]
```

**REMINDER:** You MUST define `methods` using the IR actions above for all interactive components. Infer the necessary interactions from the user request and component relationships. Use the patterns above as guides. The application MUST be functional based on your generated IR.

# IMPORTANT ANTI-PATTERNS TO AVOID:

# 1. Incorrect Input onChange Handler:
  - **WRONG:** Using `GET_PROPERTY` to read the input's own value within its `onChange`.
    ```json
    // --- INCORRECT --- DO NOT DO THIS:
    "onChange": [
      { "type": "GET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "resultVariable": "val" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$val" } }
    ]
    ```
  - **CORRECT:** Using `GET_EVENT_DATA` to read `event.target.value` (or `event.target.checked` etc.).
    ```json
    // --- CORRECT --- USE THIS PATTERN:
    "onChange": [
      { "type": "GET_EVENT_DATA", "payload": { "path": "target.value", "resultVariable": "currentValue" } },
      { "type": "SET_PROPERTY", "payload": { "targetId": "#my-input", "propertyName": "value", "newValue": "$currentValue" } }
    ]
    ```

# 2. Modifying Own Methods:
   - Do not attempt to modify a component's own method definition (e.g., setting `methods.click` to a new IR array) from within the IR sequence for that same method.
   - Use conditional logic *within* the *existing* IR sequence (like `TOGGLE_PROPERTY`).

## RESPONSE FORMAT
Your response MUST be a complete JSON object matching this structure EXACTLY:
```json
{
  "app_name": "App Name Generated From Request",
  "app": {
    "title": "App Name Generated From Request"
  },
  "layout": {
    "type": "flex", // Or other layout types if applicable
    "direction": "vertical" // Or horizontal
  },
  "components": [
    {
      "id": "unique-component-id",
      "type": "component-type", // FROM THE AVAILABLE LIST
      "properties": { /* Component-specific properties based on documentation above */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { 
        // CRITICAL: Define methods with IR actions here for ALL interactive components!
        "click": [ /* Example for a button */
          { "type": "GET_PROPERTY", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
          // ... more actions ...
        ],
        "change": [ /* Example for an input */
          { "type": "GET_EVENT_DATA", "payload": { /*...*/ } },
          { "type": "SET_PROPERTY", "payload": { /*...*/ } }
        ]
        // ... other methods as needed (submit, keyPress, etc.) ...
      },
      "events": { /* Optional: maps frontend event names (e.g., "onClick") to method names (e.g., "click") */ },
      "itemTemplate": { /* ONLY for 'list' components needing structured items */ },
      "children": [ /* Optional: Nested component objects for containers/layout */ ]
    },
    { /* ... more components ... */ }
  ]
}
```

## IMPLEMENTATION GUIDELINES (Condensed)
- **Component IDs**: Unique, descriptive, kebab-case.
- **Methods**: **MANDATORY** for interactive elements. Use the IR actions defined above. Implement the core application logic here.
- **Styling**: Consistent, accessible, responsive.
- **Data Flow**: Define interactions clearly via IR methods connecting components.

**FINAL REQUIREMENT: ALL interactive elements (buttons, inputs, checkboxes, selects, interactive list items, etc.) MUST have appropriate methods (`click`, `change`, etc.) defined using the IR actions to ensure functionality.**

**FINAL REMINDER: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT.**

FAILURE TO INCLUDE PROPERTIES AND METHODS WILL RESULT IN A NON-FUNCTIONAL UI!
--- End of Prompt ---

--- Prompt at 2025-04-20 00:03:03.809846 ---
# MORPHEO AI UI CONFIGURATION GENERATOR

**IMPORTANT: Your *only* output must be a single, valid JSON object representing the `AppConfig`. Do not include conversational text, explanations, apologies, or markdown formatting outside the main JSON structure. Start the response directly with ```json and end it directly with ```.**

## YOUR ROLE
You are an expert frontend developer tasked with translating a user request into a structured JSON configuration for the Morpheo UI system. You must use ONLY the components and Intermediate Representation (IR) actions defined below.

## USER REQUEST
```
Create a application for: a nice todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible
```

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects.
- For themed backgrounds, use colors that evoke the theme.
- Only use image URLs if explicitly provided by the user or if essential for the component (e.g., an avatar).
- Never use placeholder paths like 'path/to/image.jpg'.
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible.

## CORE PRINCIPLES
Morpheo is an AI-driven component system. Follow these principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior (e.g., calculator logic, specific validation rules). The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types (e.g., no `TodoListComponent`, build it from `list`, `text-input`, `button`).
4.  **Infer Relationships & Implement Interactions**: Analyze the user request and the relationship between components. **CRITICAL:** Define `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.) to make the application functional. For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input).
5.  **Completeness Check**: Before outputting the final JSON, mentally review the user's request and your generated `AppConfig`. Ensure all key requirements are addressed. For common application types (like Todo Lists, Counters, Forms, Calculators, Camera Apps), verify that *all standard features* are implemented using the available components and documented IR Patterns (e.g., a todo list needs add, display, *and* delete functionality). If a core part is missing, revise the configuration.

## STRICT RULES & CONSTRAINTS
-   Your *only* output is the single `AppConfig` JSON object.
-   DO NOT include any text, explanations, or markdown outside the ```json block.
-   DO NOT invent properties or methods for components that are not explicitly listed in their definition under 'Available Components'.
-   DO NOT generate raw JavaScript code strings for methods. Always use the defined IR Actions documented below.
-   Ensure every component definition includes a unique `id` property.
-   All parameters for an IR Action *must* be nested within a `payload` object, like `{ "type": "ACTION", "payload": { "param": "value" } }`.
-   Use `properties` for component-specific attributes, `styles` for CSS styling, and `methods` for interactivity via IR actions.

## YOUR TASK
Generate a complete JSON configuration (`AppConfig`) for a UI application that satisfies the user's request, adhering strictly to the principles, rules, components, and IR definitions below.

---

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Properties`, `Methods`, `Styles`, and **`Usage Notes/IR Patterns`** for required implementations.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. The primary tool for organizing UI structure.
    -   Properties:
        -   `className` (string): For applying custom CSS classes (can be updated via `SET_PROPERTY`).
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `gap`, `border`, `borderRadius`, `backgroundColor`, `width`, `height`, etc.
    -   Usage Notes: Use nested containers to build complex layouts.

-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid). Useful for structured layouts with consistent spacing.
    -   Properties:
        -   `container` (boolean): If true, acts as the grid container.
        -   `item` (boolean): If true, acts as a grid item.
        -   `spacing` (number): Defines gap between items (multiplied by theme spacing unit).
        -   `direction` ('row' | 'column'): Flex direction. Default: 'row'.
        -   `wrap` ('wrap' | 'nowrap'): Flex wrap. Default: 'wrap'.
        -   `xs`, `sm`, `md`, `lg`, `xl` (number): Responsive grid item sizing (1-12).
        -   `className` (string): Custom CSS classes.
    -   Styles: Can be styled like a container.

-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow. Good for grouping related content visually.
    -   Properties:
        -   `elevation` (number 0-5): Shadow depth. Default: 1.
        *   `variant` ('default' | 'outlined'): Card style. Default: 'default'.
        *   `title` (string): Optional card title text.
        *   `subtitle` (string): Optional card subtitle text.
        *   `headerDivider` (boolean): Show divider below header.
        *   `footerDivider` (boolean): Show divider above footer.
        *   `clickable` (boolean): Apply hover/click effects.
        -   `className` (string): Custom CSS classes.
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Methods: Can have `click`, `mouseEnter`, `mouseLeave` methods if `clickable` is true.

-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure (rendered as `<header>`/`<footer>`).
    -   Properties: `className` (string).
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`, `color`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties:
        -   `content` (string): The text to display. **Update via `SET_PROPERTY`.**
        -   `variant` ('p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'span'): Semantic HTML tag. Default: 'p'.
        -   `className` (string): Custom CSS classes (allows dynamic style changes via `SET_PROPERTY`).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`, `lineHeight`, `textDecoration`, etc.

-   **`image`**
    -   Purpose: Displays an image.
    -   Properties:
        -   `src` (string URL): REQUIRED. Image source URL.
        -   `alt` (string): REQUIRED. Alternative text for accessibility.
        -   `className` (string).
    -   Styles: `width`, `height`, `objectFit` ('cover', 'contain', etc.), `borderRadius`, `aspectRatio`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties:
        -   `content` (string): The text displayed on the button. REQUIRED.
        -   `variant` ('primary' | 'secondary' | 'text' | etc.): Visual style.
        -   `disabled` (boolean): If true, button is not interactive. Default: false. Can be updated via `SET_PROPERTY`.
        -   `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`, `fontSize`.
    -   Methods: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence to be functional. Can also use `mouseEnter`/`mouseLeave`.

-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties:
        -   `value` (string): The current value of the input. REQUIRED for controlled input.
        -   `placeholder` (string): Text shown when the input is empty.
        -   `label` (string): Optional label displayed near the input.
        -   `type` ('text' | 'password' | 'email' | 'number' | 'tel' | 'search' | 'url'): Input type. Default: 'text'.
        -   `disabled` (boolean): If true, input is non-interactive. Default: false.
        -   `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `fontSize`.
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern). Can also use `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties:
        -   `value` (string): The current value. REQUIRED for controlled input.
        -   `placeholder` (string).
        -   `label` (string).
        -   `rows` (number): Suggested number of visible text lines.
        -   `disabled` (boolean). Default: false.
        -   `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern). Can also use `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

-   **`checkbox`**
    -   Purpose: A checkbox input for toggling a boolean state.
    -   Properties:
        -   `label` (string): Text label associated with the checkbox.
        -   `checked` (boolean): The current state. REQUIRED for controlled input.
        -   `disabled` (boolean). Default: false.
        -   `className` (string).
    -   Styles: `margin`.
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern).

-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one option can be selected.
    -   Properties:
        -   `options` (Array<{label: string, value: string}>): REQUIRED. Defines the radio buttons.
        -   `value` (string): The value of the currently selected option. REQUIRED for controlled input.
        -   `name` (string): REQUIRED. Groups the radio buttons logically.
        -   `label` (string): Optional label for the group.
        -   `disabled` (boolean): Disables the entire group. Default: false.
        -   `className` (string): Applied to the container.
    -   Styles: Styles apply to the container (e.g., `display: flex`, `gap`).
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern).

-   **`select`** (Dropdown)
    -   Purpose: A dropdown selection input.
    -   Properties:
        -   `label` (string): Optional label for the dropdown.
        -   `options` (Array<{value: string, label: string}>): REQUIRED. Defines the dropdown options.
        -   `value` (string): The value of the currently selected option. REQUIRED for controlled input.
        -   `placeholder` (string): Text shown when no option is selected.
        -   `disabled` (boolean). Default: false.
        -   `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `backgroundColor`.
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern). Can also use `focus`, `blur`.

-   **`form`**
    -   Purpose: Semantic grouping for input elements. Does not automatically handle submission; use a button's `click` method within the form.
    -   Properties:
        -   `className` (string).
    -   Styles: Can be styled like a container.
    -   Methods: Can optionally have a `methods.submit` handler (often triggered by Enter key), but button clicks are more common for explicit submission.

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties:
        -   `items` (array): REQUIRED. Array of data items (can be strings, numbers, or objects). **Managed via `ADD_ITEM`/`REMOVE_ITEM` actions.**
        -   `itemTemplate` (object): **REQUIRED for structured items.** A single component definition object describing the structure for *each* item in the `items` array. Placeholders like `{{item}}`, `{{item.fieldName}}`, `{{index}}`, and `{itemId}` can be used within the template's properties and method payloads; they will be replaced when `ADD_ITEM` is used.
        -   `ordered` (boolean): Use `<ol>` instead of `<ul>`. Default: false.
        -   `className` (string): Applied to the `ul` or `ol` element.
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: See "List Manipulation" IR Patterns. Do not directly set `properties.items` in methods; use `ADD_ITEM`/`REMOVE_ITEM`.

-   **`datagrid`**
    -   Purpose: Displays tabular data.
    -   Properties:
        -   `data` (array): REQUIRED. Array of data objects.
        -   `columns` (array): REQUIRED. Defines table columns (e.g., `{ field: 'id', headerName: 'ID', width: 90 }`).
        -   `pagination` (boolean): Enable pagination.
        -   `pageSize` (number): Rows per page.
        -   `sortable` (boolean): Enable column sorting.
        -   `filterable` (boolean): Enable filtering.
        -   `className` (string).
    -   Styles: `height`, `width`.
    -   Usage Notes: Data typically updated via `SET_PROPERTY` on `data`.

-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data. Complex; use only if explicitly requested.
    -   Properties: Vary significantly. Typically include `data` (array), configuration keys (`xKey`, `yKey`, `labelKey`, `valueKey`), `title` (string), `colors` (array).
    -   Styles: `height`, `width`.
    -   Usage Notes: Data typically updated via `SET_PROPERTY` on `data`.

### Media

-   **`video`**
    -   Purpose: Displays video, optionally from the device camera.
    -   Properties:
        -   `src` (string URL): URL for video file (if not using camera).
        -   `useCamera` (boolean): If true, attempts to access the device camera. Default: false.
        -   `facingMode` ('user' | 'environment'): Camera to use. Default: 'user'.
        -   `autoPlay` (boolean): Start playback automatically. Default: false.
        -   `controls` (boolean): Show default video controls. Default: true.
        -   `muted` (boolean): Mute audio. Default: false.
        -   `className` (string).
    -   Styles: `width`, `height`, `objectFit` ('cover', 'contain').
    -   Usage Notes: Core component for camera apps. Applying CSS filters via `SET_PROPERTY` on `styles` is possible for simple effects. For complex filters or frame manipulation, `canvas` is usually needed alongside this.

-   **`canvas`**
    -   Purpose: A drawing surface, often used for image/video manipulation or custom graphics.
    -   Properties:
        -   `width` (number): Canvas width in pixels.
        -   `height` (number): Canvas height in pixels.
        -   `className` (string).
    -   Styles: `border`, `backgroundColor`.
    -   Usage Notes: Logic is typically handled by custom JS functions called via `CALL_METHOD`, as direct IR manipulation is limited.

### Utility (Use Sparingly)

-   **`script`**
    -   Purpose: Embeds custom JavaScript. **STRONGLY DISCOURAGED.** Prefer using the IR for all logic. Use only as a last resort if IR cannot achieve the required effect.
    -   Properties: `content` (string containing JS code) or `src` (URL of JS file).
    -   Usage Notes: Code runs in the global scope. May be blocked or ignored by the frontend for security.

---

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**CRITICAL: DO NOT GENERATE JAVASCRIPT CODE STRINGS FOR METHODS.** Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**.

**Structure:**
-   The `methods` object contains key-value pairs.
-   Keys are **event names** (e.g., `"click"`, `"change"`, `"keyPress"`).
-   Values are **arrays `[]` of IR action objects** that execute sequentially when the event occurs.

**Supported Events:** You can define methods for standard DOM events like `click`, `change`, `submit`, `mouseEnter`, `mouseLeave`, `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

**Variables:**
-   Actions like `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables using the `resultVariable` parameter (e.g., `"resultVariable": "inputValue"`).
-   Use the variable name prefixed with `$` (e.g., `"$inputValue"`) in the `newValue`, `itemValue`, `message`, or `args` parameters of subsequent actions *within the same method execution*.
-   Variables are local to a single method execution sequence and do not persist.

---

## IR ACTION DEFINITIONS

Each action is an object with a `type` and a **REQUIRED `payload` object** containing all parameters.

1.  **`GET_PROPERTY`**
    -   Purpose: Reads a property or style value from a target component and stores it in a variable.
    -   `payload`:
        -   `targetId` (string): ID of the component to read from.
        -   `propertyName` (string): Name of the property (e.g., `"value"`, `"checked"`, `"items"`) or style (e.g., `"styles.color"`, `"styles.display"`).
        -   `resultVariable` (string): Name of the variable to store the retrieved value in (e.g., `"currentValue"`).

2.  **`GET_EVENT_DATA`**
    -   Purpose: Reads data from the triggering event object and stores it in a variable.
    -   `payload`:
        -   `path` (string): Path to the desired data within the event object (e.g., `"target.value"`, `"key"`, `"target.checked"`, `"clientX"`).
        -   `resultVariable` (string): Name of the variable to store the event data in (e.g., `"keyPressed"`).

3.  **`SET_PROPERTY`**
    -   Purpose: Writes/updates a property or style value on a target component.
    -   `payload`:
        -   `targetId` (string): ID of the component to update.
        -   `propertyName` (string): Name of the property (e.g., `"value"`, `"checked"`, `"items"`, `"className"`) or style (e.g., `"styles.fontWeight"`, `"styles.backgroundColor"`).
        -   `newValue` (any): The new value to set. Can be a literal (string, number, boolean, object, array) or a variable (`"$variableName"`).

4.  **`ADD_ITEM`**
    -   Purpose: Adds an item to a list component's `properties.items` array. If the list has an `itemTemplate`, the template is processed using the `itemValue`.
    -   `payload`:
        -   `targetId` (string): ID of the `list` component.
        -   `itemValue` (any): The item to add. Can be a literal (string, number, object) or a variable (`"$variableName"`). If an object, its properties can be used to populate the `itemTemplate`.

5.  **`REMOVE_ITEM`**
    -   Purpose: Removes an item from a list component's `properties.items` array.
    -   `payload`:
        -   `targetId` (string): ID of the `list` component.
        -   `itemIdentifier` (string | number): **REQUIRED.** Specifies the item to remove.
            -   **By ID (Preferred):** Use the unique ID assigned to the item (often available as `{itemId}` within the `itemTemplate` context). Pass this ID as a string.
            -   **By Index:** Pass the numeric index of the item to remove.
            -   **By Value (Fallback):** Pass the actual item value (less reliable for objects).
    -   Usage Note: When triggering removal from within an `itemTemplate` (e.g., a delete button), use the `{itemId}` placeholder for `itemIdentifier`.

6.  **`LOG_MESSAGE`**
    -   Purpose: Logs a message to the browser's developer console for debugging.
    -   `payload`:
        -   `message` (string): The message to log. Can include variables like `"Current value: $currentValue"`.

7.  **`CALL_METHOD`**
    -   Purpose: Executes an IR method defined on another component.
    -   `payload`:
        -   `targetId` (string): ID of the component whose method should be called.
        -   `methodName` (string): Name of the method defined in the target component's `methods` object (e.g., `"increment"`, `"reset"`).
        -   `args` (array, optional): An array of values (literals or `"$variableName"`) to pass as arguments to the target method. (Note: Receiving/using args in the target method depends on frontend implementation).

---

## COMMON IR USAGE PATTERNS

Use these patterns as guides for implementing common interactions.

### Pattern: Controlled Input (Required for `text-input`, `textarea`, `select`, `checkbox`, `radio-group`)

```json
// Component: `my-input` (Type: text-input)
// Purpose: Update the input's 'value' property whenever the user types.
"methods": {
  "change": [
    {
      "type": "GET_EVENT_DATA",
      "payload": {
        "path": "target.value", // For checkbox: "target.checked"
        "resultVariable": "newValueFromEvent"
      }
    },
    {
      "type": "SET_PROPERTY",
      "payload": {
        "targetId": "my-input",
        "propertyName": "value", // For checkbox: "checked"
        "newValue": "$newValueFromEvent"
      }
    }
    // Optional: Add actions here to react to the change, e.g., trigger validation
  ]
}
```

### Pattern: List Manipulation - Add Item from Input

```json
// Components: `new-item-input` (text-input), `add-item-button` (button), `my-task-list` (list)
// Purpose: Add the text from the input to the list when the button is clicked, then clear the input.
// In methods for `add-item-button`:
"click": [
  {
    "type": "GET_PROPERTY",
    "payload": {
      "targetId": "new-item-input",
      "propertyName": "value",
      "resultVariable": "newItemText"
    }
  },
  // Optional: Check if newItemText is not empty before adding
  {
    "type": "ADD_ITEM",
    "payload": {
      "targetId": "my-task-list",
      "itemValue": "$newItemText" // Assuming items are strings, or an object if itemTemplate expects it
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "new-item-input",
      "propertyName": "value",
      "newValue": "" // Clear the input field
    }
  }
]
```

### Pattern: List Manipulation - Delete Item from Template

```json
// Component: `my-list` (list with itemTemplate)
// Purpose: A delete button within each list item removes that specific item.
// Within the `itemTemplate` object:
{
  "type": "container", // Example: item container
  "id": "item-container-{{itemId}}", // Unique ID using placeholder
  "children": [
    {
      "type": "text",
      "id": "item-text-{{itemId}}",
      "properties": { "content": "{{item}}" } // Display item content (assuming item is string)
      // Or: "content": "{{item.name}}" if item is an object
    },
    {
      "type": "button",
      "id": "delete-btn-{{itemId}}",
      "properties": { "content": "Delete" },
      "methods": {
        "click": [
          {
            "type": "REMOVE_ITEM",
            "payload": {
              "targetId": "my-list", // ID of the parent list
              "itemIdentifier": "{itemId}" // Use the unique item ID placeholder
            }
          }
        ]
      }
    }
  ]
}
```

### Pattern: Calling Another Component's Method

```json
// Components: `trigger-button`, `counter-display` (text), `increment-logic-holder`
// Purpose: Button click calls an 'increment' method defined elsewhere.
// In methods for `increment-logic-holder`:
"increment": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "counter-display", "propertyName": "content", "resultVariable": "currentCountStr" } },
  // Logic to convert currentCountStr to number, increment, (Requires more advanced logic/helpers not shown)
  // { "type": "SET_PROPERTY", "payload": { "targetId": "counter-display", "propertyName": "content", "newValue": "$newCount" } }
],
// In methods for `trigger-button`:
"click": [
  {
    "type": "CALL_METHOD",
    "payload": {
      "targetId": "increment-logic-holder",
      "methodName": "increment"
      // "args": [] // Optional arguments
    }
  }
]
```

### Pattern: Dynamic Styling

```json
// Components: `style-button`, `target-text`
// Purpose: Button click toggles the boldness of the target text.
// In methods for `style-button`:
"click": [
  {
    "type": "GET_PROPERTY",
    "payload": { "targetId": "target-text", "propertyName": "styles.fontWeight", "resultVariable": "currentWeight" }
  },
  // NOTE: This requires IF logic, which IR doesn't directly support.
  // A more robust way might involve a dedicated state property and SET_PROPERTY based on that.
  // Simplified Conceptual Example (Assumes frontend might handle toggle logic within SET_PROPERTY for known pairs):
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "target-text",
      "propertyName": "styles.fontWeight",
      // Conceptual: Frontend would need logic to interpret this as a toggle
      "newValue": { "_internal_toggle": ["normal", "bold"] }
    }
  }
  // Alternative using className (requires CSS for '.bold-text'):
  // { "type": "SET_PROPERTY", "payload": { "targetId": "target-text", "propertyName": "className", "newValue": /* Logic to add/remove 'bold-text' */ } }
]
```

### (Hypothetical) Pattern: Apply Filter using CALL_METHOD

```json
// Requires: Frontend JS function window.$morpheo.applyFilter(videoId, filterName) exists.
// Components: `filter-sepia-button`, `main-video` (video component with useCamera: true)
// In methods for `filter-sepia-button`:
"click": [
  {
    "type": "LOG_MESSAGE",
    "payload": { "message": "Applying Sepia Filter" }
  },
  {
    "type": "CALL_METHOD", // Assumes a hypothetical JS function exists
    "payload": {
      "targetId": "window", // Special target indicating global scope
      "methodName": "$morpheo.applyFilter", // Path to the JS function
      "args": ["main-video", "sepia"] // Pass video ID and filter name
    }
  }
  // To turn off, another button might call:
  // { "type": "CALL_METHOD", "payload": { "targetId": "window", "methodName": "$morpheo.applyFilter", "args": ["main-video", "none"] } }
]
```

---

**GENERATE THE `AppConfig` JSON BELOW:**
```json
{
  "app": {
    "name": "Generated App",
    "description": "App generated based on user request",
    "theme": "light" // Example theme
  },
  "layout": {
    "type": "singlepage", // e.g., 'singlepage', 'sidebar'
    "regions": ["main"] // e.g., ['header', 'main', 'footer'] or ['sidebar', 'main']
  },
  "components": [
    // ... Your generated component definitions go here ...
    // Example:
    // {
    //   "id": "my-button",
    //   "type": "button",
    //   "region": "main",
    //   "properties": { "content": "Click Me" },
    //   "styles": { "backgroundColor": "blue", "color": "white" },
    //   "methods": {
    //     "click": [
    //       { "type": "LOG_MESSAGE", "payload": { "message": "Button Clicked!" } }
    //     ]
    //   }
    // }
  ]
}
```
--- End of Prompt ---

--- Prompt at 2025-04-20 00:03:34.911457 ---
# MORPHEO AI UI CONFIGURATION GENERATOR

**IMPORTANT: Your *only* output must be a single, valid JSON object representing the `AppConfig`. Do not include conversational text, explanations, apologies, or markdown formatting outside the main JSON structure. Start the response directly with ```json and end it directly with ```.**

## YOUR ROLE
You are an expert frontend developer tasked with translating a user request into a structured JSON configuration for the Morpheo UI system. You must use ONLY the components and Intermediate Representation (IR) actions defined below.

## USER REQUEST
```
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible
```

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects.
- For themed backgrounds, use colors that evoke the theme.
- Only use image URLs if explicitly provided by the user or if essential for the component (e.g., an avatar).
- Never use placeholder paths like 'path/to/image.jpg'.
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible.

## CORE PRINCIPLES
Morpheo is an AI-driven component system. Follow these principles:

1.  **Zero Application-Specific Logic**: No hardcoded behavior (e.g., calculator logic, specific validation rules). The frontend provides generic components; YOU provide the application logic via the IR in `methods`.
2.  **Pure AI-Driven Generation**: You determine components, layout, styles, and behavior based *only* on the user request and these instructions.
3.  **Generic Component System**: Use the reusable building blocks listed below. Do not invent new, specialized component types (e.g., no `TodoListComponent`, build it from `list`, `text-input`, `button`).
4.  **Infer Relationships & Implement Interactions**: Analyze the user request and the relationship between components. **CRITICAL:** Define `methods` using the IR for ALL interactive components (buttons, inputs, checkboxes, list items with actions, etc.) to make the application functional. For example, an input field and an 'Add' button near a list strongly imply the need for IR methods to connect them (read input value, add to list, clear input).
5.  **Completeness Check**: Before outputting the final JSON, mentally review the user's request and your generated `AppConfig`. Ensure all key requirements are addressed. For common application types (like Todo Lists, Counters, Forms, Calculators, Camera Apps), verify that *all standard features* are implemented using the available components and documented IR Patterns (e.g., a todo list needs add, display, *and* delete functionality). If a core part is missing, revise the configuration.

## STRICT RULES & CONSTRAINTS
-   Your *only* output is the single `AppConfig` JSON object.
-   DO NOT include any text, explanations, or markdown outside the ```json block.
-   DO NOT invent properties or methods for components that are not explicitly listed in their definition under 'Available Components'.
-   DO NOT generate raw JavaScript code strings for methods. Always use the defined IR Actions documented below.
-   Ensure every component definition includes a unique `id` property.
-   All parameters for an IR Action *must* be nested within a `payload` object, like `{ "type": "ACTION", "payload": { "param": "value" } }`.
-   Use `properties` for component-specific attributes, `styles` for CSS styling, and `methods` for interactivity via IR actions.

## YOUR TASK
Generate a complete JSON configuration (`AppConfig`) for a UI application that satisfies the user's request, adhering strictly to the principles, rules, components, and IR definitions below.

---

## AVAILABLE COMPONENTS

Here is a list of available base components. Use these as building blocks. Pay close attention to the `Properties`, `Methods`, `Styles`, and **`Usage Notes/IR Patterns`** for required implementations.

### Layout & Structure

-   **`container`** (or `div`)
    -   Purpose: A flexible layout element to group other components. The primary tool for organizing UI structure.
    -   Properties:
        -   `className` (string): For applying custom CSS classes (can be updated via `SET_PROPERTY`).
    -   Styles: Use `display: flex`, `flexDirection`, `alignItems`, `justifyContent`, `padding`, `margin`, `gap`, `border`, `borderRadius`, `backgroundColor`, `width`, `height`, etc.
    -   Usage Notes: Use nested containers to build complex layouts.

-   **`grid`**
    -   Purpose: Implements a flexbox-based grid system (similar to Material UI Grid). Useful for structured layouts with consistent spacing.
    -   Properties:
        -   `container` (boolean): If true, acts as the grid container.
        -   `item` (boolean): If true, acts as a grid item.
        -   `spacing` (number): Defines gap between items (multiplied by theme spacing unit).
        -   `direction` ('row' | 'column'): Flex direction. Default: 'row'.
        -   `wrap` ('wrap' | 'nowrap'): Flex wrap. Default: 'wrap'.
        -   `xs`, `sm`, `md`, `lg`, `xl` (number): Responsive grid item sizing (1-12).
        -   `className` (string): Custom CSS classes.
    -   Styles: Can be styled like a container.

-   **`card`**
    -   Purpose: A container styled as a card, often with elevation/shadow. Good for grouping related content visually.
    -   Properties:
        -   `elevation` (number 0-5): Shadow depth. Default: 1.
        *   `variant` ('default' | 'outlined'): Card style. Default: 'default'.
        *   `title` (string): Optional card title text.
        *   `subtitle` (string): Optional card subtitle text.
        *   `headerDivider` (boolean): Show divider below header.
        *   `footerDivider` (boolean): Show divider above footer.
        *   `clickable` (boolean): Apply hover/click effects.
        -   `className` (string): Custom CSS classes.
    -   Styles: `padding`, `margin`, `backgroundColor`, `borderRadius`.
    -   Methods: Can have `click`, `mouseEnter`, `mouseLeave` methods if `clickable` is true.

-   **`header`**, **`footer`**
    -   Purpose: Semantic elements for page structure (rendered as `<header>`/`<footer>`).
    -   Properties: `className` (string).
    -   Styles: Typically styled with `padding`, `backgroundColor`, `border`, `color`.

### Text & Content

-   **`text`** (or `p`, `h1`-`h6`, `span`)
    -   Purpose: Displays text content.
    -   Properties:
        -   `content` (string): The text to display. **Update via `SET_PROPERTY`.**
        -   `variant` ('p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'span'): Semantic HTML tag. Default: 'p'.
        -   `className` (string): Custom CSS classes (allows dynamic style changes via `SET_PROPERTY`).
    -   Styles: `fontSize`, `fontWeight`, `color`, `textAlign`, `margin`, `padding`, `lineHeight`, `textDecoration`, etc.

-   **`image`**
    -   Purpose: Displays an image.
    -   Properties:
        -   `src` (string URL): REQUIRED. Image source URL.
        -   `alt` (string): REQUIRED. Alternative text for accessibility.
        -   `className` (string).
    -   Styles: `width`, `height`, `objectFit` ('cover', 'contain', etc.), `borderRadius`, `aspectRatio`.

### Input & Controls

-   **`button`**
    -   Purpose: An interactive button to trigger actions.
    -   Properties:
        -   `content` (string): The text displayed on the button. REQUIRED.
        -   `variant` ('primary' | 'secondary' | 'text' | etc.): Visual style.
        -   `disabled` (boolean): If true, button is not interactive. Default: false. Can be updated via `SET_PROPERTY`.
        -   `className` (string).
    -   Styles: `padding`, `margin`, `backgroundColor`, `color`, `border`, `borderRadius`, `cursor`, `fontSize`.
    -   Methods: **CRITICAL:** Requires a `methods.click` definition containing an IR action sequence to be functional. Can also use `mouseEnter`/`mouseLeave`.

-   **`text-input`** (or `input`)
    -   Purpose: Field for single-line text entry.
    -   Properties:
        -   `value` (string): The current value of the input. REQUIRED for controlled input.
        -   `placeholder` (string): Text shown when the input is empty.
        -   `label` (string): Optional label displayed near the input.
        -   `type` ('text' | 'password' | 'email' | 'number' | 'tel' | 'search' | 'url'): Input type. Default: 'text'.
        -   `disabled` (boolean): If true, input is non-interactive. Default: false.
        -   `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `fontSize`.
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern). Can also use `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

-   **`textarea`**
    -   Purpose: Field for multi-line text entry.
    -   Properties:
        -   `value` (string): The current value. REQUIRED for controlled input.
        -   `placeholder` (string).
        -   `label` (string).
        -   `rows` (number): Suggested number of visible text lines.
        -   `disabled` (boolean). Default: false.
        -   `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `minHeight`, `resize`.
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern). Can also use `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

-   **`checkbox`**
    -   Purpose: A checkbox input for toggling a boolean state.
    -   Properties:
        -   `label` (string): Text label associated with the checkbox.
        -   `checked` (boolean): The current state. REQUIRED for controlled input.
        -   `disabled` (boolean). Default: false.
        -   `className` (string).
    -   Styles: `margin`.
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern).

-   **`radio-group`**
    -   Purpose: Group of radio buttons where only one option can be selected.
    -   Properties:
        -   `options` (Array<{label: string, value: string}>): REQUIRED. Defines the radio buttons.
        -   `value` (string): The value of the currently selected option. REQUIRED for controlled input.
        -   `name` (string): REQUIRED. Groups the radio buttons logically.
        -   `label` (string): Optional label for the group.
        -   `disabled` (boolean): Disables the entire group. Default: false.
        -   `className` (string): Applied to the container.
    -   Styles: Styles apply to the container (e.g., `display: flex`, `gap`).
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern).

-   **`select`** (Dropdown)
    -   Purpose: A dropdown selection input.
    -   Properties:
        -   `label` (string): Optional label for the dropdown.
        -   `options` (Array<{value: string, label: string}>): REQUIRED. Defines the dropdown options.
        -   `value` (string): The value of the currently selected option. REQUIRED for controlled input.
        -   `placeholder` (string): Text shown when no option is selected.
        -   `disabled` (boolean). Default: false.
        -   `className` (string).
    -   Styles: `padding`, `margin`, `border`, `borderRadius`, `width`, `backgroundColor`.
    -   Methods: **CRITICAL:** Requires `methods.change` for interactivity (see IR Pattern). Can also use `focus`, `blur`.

-   **`form`**
    -   Purpose: Semantic grouping for input elements. Does not automatically handle submission; use a button's `click` method within the form.
    -   Properties:
        -   `className` (string).
    -   Styles: Can be styled like a container.
    -   Methods: Can optionally have a `methods.submit` handler (often triggered by Enter key), but button clicks are more common for explicit submission.

### Lists & Data Display

-   **`list`**
    -   Purpose: Displays a dynamic list of items.
    -   Properties:
        -   `items` (array): REQUIRED. Array of data items (can be strings, numbers, or objects). **Managed via `ADD_ITEM`/`REMOVE_ITEM` actions.**
        -   `itemTemplate` (object): **REQUIRED for structured items.** A single component definition object describing the structure for *each* item in the `items` array. Placeholders like `{{item}}`, `{{item.fieldName}}`, `{{index}}`, and `{itemId}` can be used within the template's properties and method payloads; they will be replaced when `ADD_ITEM` is used.
        -   `ordered` (boolean): Use `<ol>` instead of `<ul>`. Default: false.
        -   `className` (string): Applied to the `ul` or `ol` element.
    -   Styles: `padding`, `margin`, `listStyleType`.
    -   Usage Notes: See "List Manipulation" IR Patterns. Do not directly set `properties.items` in methods; use `ADD_ITEM`/`REMOVE_ITEM`.

-   **`datagrid`**
    -   Purpose: Displays tabular data.
    -   Properties:
        -   `data` (array): REQUIRED. Array of data objects.
        -   `columns` (array): REQUIRED. Defines table columns (e.g., `{ field: 'id', headerName: 'ID', width: 90 }`).
        -   `pagination` (boolean): Enable pagination.
        -   `pageSize` (number): Rows per page.
        -   `sortable` (boolean): Enable column sorting.
        -   `filterable` (boolean): Enable filtering.
        -   `className` (string).
    -   Styles: `height`, `width`.
    -   Usage Notes: Data typically updated via `SET_PROPERTY` on `data`.

-   **Charts (`linechart`, `barchart`, `piechart`, `advancedchart`, `dataseries`)**
    -   Purpose: Visualizes data. Complex; use only if explicitly requested.
    -   Properties: Vary significantly. Typically include `data` (array), configuration keys (`xKey`, `yKey`, `labelKey`, `valueKey`), `title` (string), `colors` (array).
    -   Styles: `height`, `width`.
    -   Usage Notes: Data typically updated via `SET_PROPERTY` on `data`.

### Media

-   **`video`**
    -   Purpose: Displays video, optionally from the device camera.
    -   Properties:
        -   `src` (string URL): URL for video file (if not using camera).
        -   `useCamera` (boolean): If true, attempts to access the device camera. Default: false.
        -   `facingMode` ('user' | 'environment'): Camera to use. Default: 'user'.
        -   `autoPlay` (boolean): Start playback automatically. Default: false.
        -   `controls` (boolean): Show default video controls. Default: true.
        -   `muted` (boolean): Mute audio. Default: false.
        -   `className` (string).
    -   Styles: `width`, `height`, `objectFit` ('cover', 'contain').
    -   Usage Notes: Core component for camera apps. Applying CSS filters via `SET_PROPERTY` on `styles` is possible for simple effects. For complex filters or frame manipulation, `canvas` is usually needed alongside this.

-   **`canvas`**
    -   Purpose: A drawing surface, often used for image/video manipulation or custom graphics.
    -   Properties:
        -   `width` (number): Canvas width in pixels.
        -   `height` (number): Canvas height in pixels.
        -   `className` (string).
    -   Styles: `border`, `backgroundColor`.
    -   Usage Notes: Logic is typically handled by custom JS functions called via `CALL_METHOD`, as direct IR manipulation is limited.

### Utility (Use Sparingly)

-   **`script`**
    -   Purpose: Embeds custom JavaScript. **STRONGLY DISCOURAGED.** Prefer using the IR for all logic. Use only as a last resort if IR cannot achieve the required effect.
    -   Properties: `content` (string containing JS code) or `src` (URL of JS file).
    -   Usage Notes: Code runs in the global scope. May be blocked or ignored by the frontend for security.

---

## DEFINING INTERACTIVITY: METHODS & INTERMEDIATE REPRESENTATION (IR)

**CRITICAL: DO NOT GENERATE JAVASCRIPT CODE STRINGS FOR METHODS.** Define component logic within the `methods` object using a structured **Intermediate Representation (IR)**.

**Structure:**
-   The `methods` object contains key-value pairs.
-   Keys are **event names** (e.g., `"click"`, `"change"`, `"keyPress"`).
-   Values are **arrays `[]` of IR action objects** that execute sequentially when the event occurs.

**Supported Events:** You can define methods for standard DOM events like `click`, `change`, `submit`, `mouseEnter`, `mouseLeave`, `focus`, `blur`, `keyPress`, `keyDown`, `keyUp`.

**Variables:**
-   Actions like `GET_PROPERTY` and `GET_EVENT_DATA` store results in temporary variables using the `resultVariable` parameter (e.g., `"resultVariable": "inputValue"`).
-   Use the variable name prefixed with `$` (e.g., `"$inputValue"`) in the `newValue`, `itemValue`, `message`, or `args` parameters of subsequent actions *within the same method execution*.
-   Variables are local to a single method execution sequence and do not persist.

---

## IR ACTION DEFINITIONS

Each action is an object with a `type` and a **REQUIRED `payload` object** containing all parameters.

1.  **`GET_PROPERTY`**
    -   Purpose: Reads a property or style value from a target component and stores it in a variable.
    -   `payload`:
        -   `targetId` (string): ID of the component to read from.
        -   `propertyName` (string): Name of the property (e.g., `"value"`, `"checked"`, `"items"`) or style (e.g., `"styles.color"`, `"styles.display"`).
        -   `resultVariable` (string): Name of the variable to store the retrieved value in (e.g., `"currentValue"`).

2.  **`GET_EVENT_DATA`**
    -   Purpose: Reads data from the triggering event object and stores it in a variable.
    -   `payload`:
        -   `path` (string): Path to the desired data within the event object (e.g., `"target.value"`, `"key"`, `"target.checked"`, `"clientX"`).
        -   `resultVariable` (string): Name of the variable to store the event data in (e.g., `"keyPressed"`).

3.  **`SET_PROPERTY`**
    -   Purpose: Writes/updates a property or style value on a target component.
    -   `payload`:
        -   `targetId` (string): ID of the component to update.
        -   `propertyName` (string): Name of the property (e.g., `"value"`, `"checked"`, `"items"`, `"className"`) or style (e.g., `"styles.fontWeight"`, `"styles.backgroundColor"`).
        -   `newValue` (any): The new value to set. Can be a literal (string, number, boolean, object, array) or a variable (`"$variableName"`).

4.  **`ADD_ITEM`**
    -   Purpose: Adds an item to a list component's `properties.items` array. If the list has an `itemTemplate`, the template is processed using the `itemValue`.
    -   `payload`:
        -   `targetId` (string): ID of the `list` component.
        -   `itemValue` (any): The item to add. Can be a literal (string, number, object) or a variable (`"$variableName"`). If an object, its properties can be used to populate the `itemTemplate`.

5.  **`REMOVE_ITEM`**
    -   Purpose: Removes an item from a list component's `properties.items` array.
    -   `payload`:
        -   `targetId` (string): ID of the `list` component.
        -   `itemIdentifier` (string | number): **REQUIRED.** Specifies the item to remove.
            -   **By ID (Preferred):** Use the unique ID assigned to the item (often available as `{itemId}` within the `itemTemplate` context). Pass this ID as a string.
            -   **By Index:** Pass the numeric index of the item to remove.
            -   **By Value (Fallback):** Pass the actual item value (less reliable for objects).
    -   Usage Note: When triggering removal from within an `itemTemplate` (e.g., a delete button), use the `{itemId}` placeholder for `itemIdentifier`.

6.  **`LOG_MESSAGE`**
    -   Purpose: Logs a message to the browser's developer console for debugging.
    -   `payload`:
        -   `message` (string): The message to log. Can include variables like `"Current value: $currentValue"`.

7.  **`CALL_METHOD`**
    -   Purpose: Executes an IR method defined on another component.
    -   `payload`:
        -   `targetId` (string): ID of the component whose method should be called.
        -   `methodName` (string): Name of the method defined in the target component's `methods` object (e.g., `"increment"`, `"reset"`).
        -   `args` (array, optional): An array of values (literals or `"$variableName"`) to pass as arguments to the target method. (Note: Receiving/using args in the target method depends on frontend implementation).

---

## COMMON IR USAGE PATTERNS

Use these patterns as guides for implementing common interactions.

### Pattern: Controlled Input (Required for `text-input`, `textarea`, `select`, `checkbox`, `radio-group`)

```json
// Component: `my-input` (Type: text-input)
// Purpose: Update the input's 'value' property whenever the user types.
"methods": {
  "change": [
    {
      "type": "GET_EVENT_DATA",
      "payload": {
        "path": "target.value", // For checkbox: "target.checked"
        "resultVariable": "newValueFromEvent"
      }
    },
    {
      "type": "SET_PROPERTY",
      "payload": {
        "targetId": "my-input",
        "propertyName": "value", // For checkbox: "checked"
        "newValue": "$newValueFromEvent"
      }
    }
    // Optional: Add actions here to react to the change, e.g., trigger validation
  ]
}
```

### Pattern: List Manipulation - Add Item from Input

```json
// Components: `new-item-input` (text-input), `add-item-button` (button), `my-task-list` (list)
// Purpose: Add the text from the input to the list when the button is clicked, then clear the input.
// In methods for `add-item-button`:
"click": [
  {
    "type": "GET_PROPERTY",
    "payload": {
      "targetId": "new-item-input",
      "propertyName": "value",
      "resultVariable": "newItemText"
    }
  },
  // Optional: Check if newItemText is not empty before adding
  {
    "type": "ADD_ITEM",
    "payload": {
      "targetId": "my-task-list",
      "itemValue": "$newItemText" // Assuming items are strings, or an object if itemTemplate expects it
    }
  },
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "new-item-input",
      "propertyName": "value",
      "newValue": "" // Clear the input field
    }
  }
]
```

### Pattern: List Manipulation - Delete Item from Template

```json
// Component: `my-list` (list with itemTemplate)
// Purpose: A delete button within each list item removes that specific item.
// Within the `itemTemplate` object:
{
  "type": "container", // Example: item container
  "id": "item-container-{{itemId}}", // Unique ID using placeholder
  "children": [
    {
      "type": "text",
      "id": "item-text-{{itemId}}",
      "properties": { "content": "{{item}}" } // Display item content (assuming item is string)
      // Or: "content": "{{item.name}}" if item is an object
    },
    {
      "type": "button",
      "id": "delete-btn-{{itemId}}",
      "properties": { "content": "Delete" },
      "methods": {
        "click": [
          {
            "type": "REMOVE_ITEM",
            "payload": {
              "targetId": "my-list", // ID of the parent list
              "itemIdentifier": "{itemId}" // Use the unique item ID placeholder
            }
          }
        ]
      }
    }
  ]
}
```

### Pattern: Calling Another Component's Method

```json
// Components: `trigger-button`, `counter-display` (text), `increment-logic-holder`
// Purpose: Button click calls an 'increment' method defined elsewhere.
// In methods for `increment-logic-holder`:
"increment": [
  { "type": "GET_PROPERTY", "payload": { "targetId": "counter-display", "propertyName": "content", "resultVariable": "currentCountStr" } },
  // Logic to convert currentCountStr to number, increment, (Requires more advanced logic/helpers not shown)
  // { "type": "SET_PROPERTY", "payload": { "targetId": "counter-display", "propertyName": "content", "newValue": "$newCount" } }
],
// In methods for `trigger-button`:
"click": [
  {
    "type": "CALL_METHOD",
    "payload": {
      "targetId": "increment-logic-holder",
      "methodName": "increment"
      // "args": [] // Optional arguments
    }
  }
]
```

### Pattern: Dynamic Styling

```json
// Components: `style-button`, `target-text`
// Purpose: Button click toggles the boldness of the target text.
// In methods for `style-button`:
"click": [
  {
    "type": "GET_PROPERTY",
    "payload": { "targetId": "target-text", "propertyName": "styles.fontWeight", "resultVariable": "currentWeight" }
  },
  // NOTE: This requires IF logic, which IR doesn't directly support.
  // A more robust way might involve a dedicated state property and SET_PROPERTY based on that.
  // Simplified Conceptual Example (Assumes frontend might handle toggle logic within SET_PROPERTY for known pairs):
  {
    "type": "SET_PROPERTY",
    "payload": {
      "targetId": "target-text",
      "propertyName": "styles.fontWeight",
      // Conceptual: Frontend would need logic to interpret this as a toggle
      "newValue": { "_internal_toggle": ["normal", "bold"] }
    }
  }
  // Alternative using className (requires CSS for '.bold-text'):
  // { "type": "SET_PROPERTY", "payload": { "targetId": "target-text", "propertyName": "className", "newValue": /* Logic to add/remove 'bold-text' */ } }
]
```

### (Hypothetical) Pattern: Apply Filter using CALL_METHOD

```json
// Requires: Frontend JS function window.$morpheo.applyFilter(videoId, filterName) exists.
// Components: `filter-sepia-button`, `main-video` (video component with useCamera: true)
// In methods for `filter-sepia-button`:
"click": [
  {
    "type": "LOG_MESSAGE",
    "payload": { "message": "Applying Sepia Filter" }
  },
  {
    "type": "CALL_METHOD", // Assumes a hypothetical JS function exists
    "payload": {
      "targetId": "window", // Special target indicating global scope
      "methodName": "$morpheo.applyFilter", // Path to the JS function
      "args": ["main-video", "sepia"] // Pass video ID and filter name
    }
  }
  // To turn off, another button might call:
  // { "type": "CALL_METHOD", "payload": { "targetId": "window", "methodName": "$morpheo.applyFilter", "args": ["main-video", "none"] } }
]
```

---

**GENERATE THE `AppConfig` JSON BELOW:**
```json
{
  "app": {
    "name": "Generated App",
    "description": "App generated based on user request",
    "theme": "light" // Example theme
  },
  "layout": {
    "type": "singlepage", // e.g., 'singlepage', 'sidebar'
    "regions": ["main"] // e.g., ['header', 'main', 'footer'] or ['sidebar', 'main']
  },
  "components": [
    // ... Your generated component definitions go here ...
    // Example:
    // {
    //   "id": "my-button",
    //   "type": "button",
    //   "region": "main",
    //   "properties": { "content": "Click Me" },
    //   "styles": { "backgroundColor": "blue", "color": "white" },
    //   "methods": {
    //     "click": [
    //       { "type": "LOG_MESSAGE", "payload": { "message": "Button Clicked!" } }
    //     ]
    //   }
    // }
  ]
}
```
--- End of Prompt ---

