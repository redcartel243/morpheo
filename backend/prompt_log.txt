--- Prompt at 2025-04-11 22:17:42.812983 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple calculator
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:18:19.349593 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:25:51.708650 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:39:53.285658 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:43:27.637210 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:47:13.753209 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:50:59.564967 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-11 22:57:19.233918 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a simple dark calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 05:42:08.312030 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:13:58.118318 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a calculator 
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:14:36.214954 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:29:07.397971 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:33:51.456665 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 06:39:19.604065 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 07:27:04.083363 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a odo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 07:28:06.692056 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 18:43:01.108613 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 18:46:36.900191 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 18:52:40.223168 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:10:16.216529 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:13:36.891167 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:16:07.290410 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:20:09.811748 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:25:00.593633 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:28:21.709318 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:30:44.008579 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:33:03.543031 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:40:05.371990 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:45:15.141048 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:47:38.849007 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:54:47.720434 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:55:21.293455 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 19:55:44.286021 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:13:54.369004 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:16:58.893616 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:23:46.206962 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 20:28:17.701117 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 21:49:23.687402 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 21:52:11.578605 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-13 21:52:47.211608 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a professional looking todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:21:56.673583 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:22:58.955530 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:24:39.562509 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:35:28.526351 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:39:16.185274 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 07:42:05.997975 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:17:37.455370 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:39:29.746292 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:42:50.039224 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 08:45:37.137907 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:38:51.521787 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:45:26.412696 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:46:01.303377 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 12:50:35.847955 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:20:49.959973 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:21:32.342934 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:42:26.735040 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:44:07.182096 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:50:43.004341 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:56:18.798945 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 16:59:47.443484 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:04:31.920272 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:24:15.324813 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:26:58.443091 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:28:12.060667 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:28:43.061759 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:29:03.656195 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:29:35.274521 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:29:56.383354 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:36:10.561906 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:38:55.982729 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:44:24.980428 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:53:05.538366 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 17:55:25.340586 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:03:17.460329 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:05:08.030104 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:07:25.430089 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:08:24.304801 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:10:48.687592 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:12:25.179759 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:17:33.189198 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:22:57.894189 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:26:14.733943 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:36:03.874841 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:38:23.872620 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 18:40:14.823613 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:32:45.981490 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:36:21.472222 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:37:11.648703 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 20:39:53.566935 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:15:35.261048 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:20:05.215264 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:20:51.317907 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:26:59.242744 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:27:02.536947 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:31:39.120171 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:42.257696 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:46.310612 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:50.708213 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:53.586641 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:56.350230 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:35:59.010484 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:02.257655 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:05.254493 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:09.465085 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:11.912304 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:14.988203 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:26.077172 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:29.430468 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:32.718347 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:35.675607 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:38.733513 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:42.149536 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:44.875810 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:48.606091 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:52.060179 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:55.756604 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:36:59.105255 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:02.804936 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo list
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:31.370995 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:34.966705 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-14 21:37:38.331993 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

IMPORTANT: ENSURE all components have detailed properties (content, placeholder, etc.) and interactive components have methods defined with proper IR actions! This is critically required!

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:30:47.081090 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:38:59.449451 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:41:46.917540 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 07:50:54.830610 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:09:21.707834 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:34:05.211195 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:40:17.077022 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:41:54.928001 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 08:47:43.209085 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 09:18:54.169763 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 09:24:11.038279 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:38:29.266560 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: A todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:44:57.796989 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:47:26.914556 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:53:58.890209 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 11:59:16.120846 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 12:11:11.039866 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 12:18:06.606486 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 13:10:20.361872 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

--- Prompt at 2025-04-15 18:41:53.282010 ---
# MORPHEO UI CONFIGURATION GENERATOR

## USER REQUEST
Create a application for: a todo app
      
For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds (like "emoji background"), use colors that evoke the theme (bright, cheerful colors for emoji)
- Only use image URLs if explicitly provided by the user (e.g., "background-image: url('https://example.com/image.jpg')")
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

For visual elements that require images:
- Use appropriate CSS styling (colors, gradients, patterns) for most visual effects
- For themed backgrounds, use colors that evoke the theme
- Only use image URLs if explicitly provided by the user
- Never use placeholder paths like 'path/to/image.jpg' or similar non-existent references
- When no image URL is provided, implement visual elements with CSS or unicode characters where possible

## CORE PRINCIPLES
Morpheo is an AI-driven component system with these fundamental principles:

1. **Zero Application-Specific Logic**: 
   - No hardcoded calculator logic, form validation, or app-specific functionality
   - All application behavior must be generated by you (the AI), not pre-built

2. **Pure AI-Driven Generation**:
   - You analyze requests and determine needed components
   - You create connections and transformations
   - You apply behaviors appropriate to the use case

3. **Generic Component System**:
   - Components are generic building blocks
   - Behaviors should be reusable across applications
   - Component behavior should adapt to the specific context

## CAMERA AND MEDIA PROCESSING REQUIREMENTS

When implementing camera-based applications or applications requiring media input:

1. **ALWAYS use the proper video component type**:
   ```json
   {
     "id": "media-input",
     "type": "video", 
     "properties": {
       "useCamera": true,
       "facingMode": "user",
       "autoPlay": true,
       "muted": true
     }
   }
   ```

2. **ALWAYS add canvas overlay for visualizations**:
   ```json
   {
     "id": "detection-overlay",
     "type": "canvas",
     "properties": {
       "overlayFor": "media-input",
       "transparent": true
     },
     "styles": {
       "position": "absolute",
       "top": "0",
       "left": "0",
       "width": "100%",
       "height": "100%"
     }
   }
   ```

3. **NEVER use static images or placeholder divs** for camera views
4. **ALWAYS implement proper camera access** using the MediaDevices API
5. **ALWAYS provide status feedback** during camera initialization and processing
6. **USE generic terminology** like "Media Analysis" or "Object Detection" instead of domain-specific terms
7. **IMPLEMENT proper cleanup** when stopping camera access

## YOUR TASK
Generate a complete JSON configuration for a UI application that satisfies the user's request.

DO NOT use templates or predefined application structures. Instead:
- Analyze what components would best serve the user's needs
- Create a component tree with appropriate nesting and organization
- Define component properties, styles, and methods
- Implement all necessary functionality through DOM manipulation ($m() selector)
- Ensure components work together seamlessly

## DOM MANIPULATION PATTERNS

The $m() selector is the primary way to manipulate the DOM. Here are common patterns:

```javascript
// Getting and setting content
const value = $m('#element-id').getProperty('content');
$m('#element-id').setProperty('content', 'New text');

// Handling input values
const inputValue = $m('#input-id').getProperty('value');
$m('#input-id').setProperty('value', '');

// Toggling visibility
$m('#element-id').setStyle('display', 'none');
$m('#element-id').setStyle('display', 'block');

// Changing appearance
$m('#element-id').setStyle('backgroundColor', '#ff0000');
$m('#element-id').setStyle('color', '#ffffff');
```

## RESPONSE FORMAT
Your response should be a complete JSON object with the following structure:
```json
{
  "app": {
    "name": "App Name",
    "description": "App Description",
    "theme": "light" or "dark" or custom color scheme
  },
  "layout": {
    "type": "singlepage",
    "regions": ["header", "main", "footer"]
  },
  "components": [
    {
      "id": "unique-id",
      "type": "component-type",
      "region": "region-name",
      "properties": { /* Component properties */ },
      "styles": { /* CSS-compatible styles */ },
      "methods": { /* Event handlers and functions */ },
      "children": [ /* For container components: nested components */ ]
    }
  ]
}
```

## IMPLEMENTATION GUIDELINES

1. **Component IDs**:
   - Must be unique across all components
   - Should be descriptive of the component's purpose
   - Use kebab-case (e.g., "user-input", "submit-button")

2. **Methods and Events**:
   - Always use the $m() selector for DOM manipulation
   - Include detailed error handling
   - Make methods concise and focused
   - Use helper functions for complex operations
   - Implement proper event binding and unbinding

3. **Styling**:
   - Use consistent color schemes
   - Ensure adequate contrast for accessibility
   - Make layouts responsive
   - Use CSS grid and flexbox for complex layouts
   - Implement progressive enhancement for advanced features

4. **Data Flow**:
   - Clearly define how data moves between components
   - Validate data at appropriate points
   - Handle edge cases and errors
   - Implement state management for complex applications
   - Use observable patterns for reactive updates

5. **Advanced Implementation**:
   - Break complex functionality into modular parts
   - Implement proper error boundaries
   - Use appropriate design patterns
   - Ensure performance by optimizing critical paths
   - Scale implementation complexity based on user requirements

IMPORTANT: RESPOND WITH VALID JSON ONLY. NO EXPLANATIONS, MARKDOWN, OR TEXT OUTSIDE THE JSON OBJECT. 
--- End of Prompt ---

